{
  parserClass="io.epigraph.idl.parser.IdlParser"

  elementTypeHolderClass="io.epigraph.idl.lexer.IdlElementTypes"
  elementTypePrefix="I_"
  elementTypeClass="io.epigraph.idl.lexer.IdlElementType"
  tokenTypeClass="io.epigraph.idl.lexer.IdlElementType"

  psiClassPrefix="Idl"
  psiImplClassSuffix="Impl"
  psiPackage="io.epigraph.idl.parser.psi"
  psiImplPackage="io.epigraph.idl.parser.psi.impl"
  psiImplUtilClass="io.epigraph.idl.parser.psi.impl.IdlPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    META = 'meta'
    FORBIDDEN = 'forbidden'
    REQURIED = 'required'
    PARAMETERS = 'parameters'
    DEFAULT = 'default'
//    PRIMITIVE = 'primitive'
//    ENUM = 'enum'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    SEMICOLON = ';'
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    TILDA = '~'
    STAR = '*'
    PLUS = '+'
    AT = '@'
    UNDERSCORE = '_'
    BANG = '!'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'

    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]

  pin(".*Body") = 1
}

// TODO proper root
root ::= namespaceDecl imports opOutputVarProjection opInputTrunkVarProjection reqOutputTrunkVarProjection

// either quoted or unquoted id
qid ::= id {
//   methods=[getName setName getCanonicalName]
   methods=[getName getCanonicalName]
}

imports ::= importStatement*
importStatement ::= 'import' fqn {pin=1 recoverWhile="importRecover"}

namespaceDecl ::= 'namespace' fqn namespaceBody? {
//  methods=[getFqn2 toString]
//  stubClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStub"
//  elementTypeClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStubElementType"
  pin=1
  recoverWhile="namespaceDeclRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqnSegment ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
fqn ::= fqnSegment ('.' fqnSegment)* {
  methods=[getFqn]
}

fqnTypeRef ::= fqn {
  name="type"
//  methods=[resolve] extends="typeRef"
}

//varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
////  methods=[setName getNameIdentifier getReference]
//}

customParam ::= qid '=' dataValue { // todo (here and schema): rename to annotation
  name="custom attribute"
//  implements="com.intellij.psi.PsiNamedElement"
//  methods = [getName setName getNameIdentifier]
  pin = 2
}

private namespaceDeclRecover ::= ! ('import' | 'namespace' )
private importRecover ::= namespaceDeclRecover

tagName ::= qid | '_' // `_` is default tag

// ============= op projections =============

opParam ::= ';' '+'? qid ':' fqnTypeRef opInputComaModelProjection opParamDefault? opParamBody? { pin = 1 }
private opParamDefault ::= '=' datum { pin=1 }
private opParamBody ::= '{' ( opParamBodyPart ','? )* '}'
private opParamBodyPart ::= customParam

// output --------------------------------------------------------

opOutputModelMeta ::= 'meta' ':' '+'? opOutputModelProjection

opOutputVarProjection ::= ( opOutputMultiTagProjection | opOutputSingleTagProjection ) opOutputVarPolymorphicTail?

opOutputMultiTagProjection ::= ':' '(' (opOutputMultiTagProjectionItem ','?)* ')' {pin=2}
opOutputSingleTagProjection ::= ( ':' '+'? tagName)? (opOutputComplexTagProjection | opOutputSimpleTagProjection )
opOutputMultiTagProjectionItem ::= '+'? tagName ( opOutputComplexTagProjection | opOutputSimpleTagProjection )

private opOutputSimpleTagProjection ::= opOutputModelProjection
private opOutputComplexTagProjection ::= '{' (opOutputModelProperty ','?)* opOutputModelProjection '}' {pin=1}

//
opOutputVarPolymorphicTail ::= opOutputVarSingleTail | opOutputVarMultiTail
opOutputVarSingleTail ::= '~' fqnTypeRef opOutputVarProjection
opOutputVarMultiTail ::= '~' '(' (opOutputVarMultiTailItem ','?)* ')' {pin=2}
opOutputVarMultiTailItem ::= fqnTypeRef opOutputVarProjection

opOutputModelProperty ::= opParam | customParam | opOutputModelMeta

opOutputModelProjection ::= ( opOutputRecordModelProjection
                            | opOutputListModelProjection
                            | opOutputMapModelProjection
//                          | opOutputEnumModelProjection
//                          | opOutputPrimitiveModelProjection
                            )?

// op output record
opOutputRecordModelProjection ::= '(' (opOutputFieldProjection ','?)* ')' { pin=1 }
opOutputFieldProjection ::= '+'? qid (opOutputComplexFieldProjection | opOutputSimpleFieldProjection)
private opOutputComplexFieldProjection ::= '{' (opOutputFieldProjectionBodyPart ','? )* opOutputVarProjection? '}'
private opOutputSimpleFieldProjection ::= opOutputVarProjection
opOutputFieldProjectionBodyPart ::= opParam | customParam

// op output list
opOutputListModelProjection ::= '*' '(' opOutputVarProjection ')' { pin=1 }

// op output map
opOutputMapModelProjection ::= opOutputKeyProjection '(' opOutputVarProjection ')' { pin=1 }
opOutputKeyProjection ::= '[' ('required' ','?| 'forbidden' ','?)? (opOutputKeyProjectionPart ','?)* ']' {pin=1}
opOutputKeyProjectionPart ::= opParam | customParam

//opOutputPrimitiveModelProjection ::= 'primitive' // ?
//opOutputEnumModelProjection ::= 'enum' // ?

// input --------------------------------------------------------

opInputModelProperty ::= opInputDefaultValue | customParam | opInputModelMeta
opInputDefaultValue ::= 'default' ':' datum {pin=1}

opInputModelMeta ::= 'meta' ':' '+'? opInputComaModelProjection

opInputVarPolymorphicTail ::= opInputVarSingleTail | opInputVarMultiTail
opInputVarSingleTail ::= '~' fqnTypeRef opInputComaVarProjection
opInputVarMultiTail ::= '~' '(' (opInputVarMultiTailItem ','?)* ')' {pin=2}
opInputVarMultiTailItem ::= fqnTypeRef opInputComaVarProjection

opInputFieldProjectionBodyPart ::= customParam

// input projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
// singular tags and fields are allowed in var and record projections. Coma can contain branching

// input trunk part

opInputTrunkVarProjection ::= ( opInputComaMultiTagProjection | opInputTrunkSingleTagProjection ) opInputVarPolymorphicTail?
opInputTrunkSingleTagProjection ::= ( ':' '+'? tagName)? (opInputTrunkComplexSingleTagProjection | opInputTrunkSimpleSingleTagProjection )
private opInputTrunkSimpleSingleTagProjection ::= opInputTrunkModelProjection
private opInputTrunkComplexSingleTagProjection ::= '{' (opInputModelProperty ','?)* opInputTrunkModelProjection '}' {pin=1}

//

opInputTrunkModelProjection ::= ( opInputTrunkRecordModelProjection
                                | opInputComaRecordModelProjection
                                | opInputComaListModelProjection
                                | opInputComaMapModelProjection
                                )? {
  extends = opInputComaModelProjection
}

// op input record trunk
opInputTrunkRecordModelProjection ::= '/' opInputTrunkFieldProjection { pin=1 }
opInputTrunkFieldProjection ::= '+'? qid (opInputTrunkComplexFieldProjection | opInputTrunkSimpleFieldProjection)
private opInputTrunkComplexFieldProjection ::= '{' (opInputFieldProjectionBodyPart ','? )* opInputTrunkVarProjection? '}'
private opInputTrunkSimpleFieldProjection ::= opInputTrunkVarProjection

// input coma part

opInputComaVarProjection ::= ( opInputComaMultiTagProjection | opInputComaSingleTagProjection ) opInputVarPolymorphicTail?
opInputComaMultiTagProjection ::= ':' '(' (opInputComaMultiTagProjectionItem ','?)* ')' {pin=2}
opInputComaSingleTagProjection ::= ( ':' '+'? tagName)? (opInputComaComplexTagProjection | opInputComaSimpleTagProjection )
opInputComaMultiTagProjectionItem ::= '+'? tagName ( opInputComaComplexTagProjection | opInputComaSimpleTagProjection )

private opInputComaSimpleTagProjection ::= opInputComaModelProjection
private opInputComaComplexTagProjection ::= '{' (opInputModelProperty ','?)* opInputComaModelProjection '}' {pin=1}
//

opInputComaModelProjection ::= ( opInputComaRecordModelProjection
                               | opInputComaListModelProjection
                               | opInputComaMapModelProjection
                               )?

// op input record
opInputComaRecordModelProjection ::= '(' (opInputComaFieldProjection ','?)* ')' { pin=1 }
opInputComaFieldProjection ::= '+'? qid (opInputComaComplexFieldProjection | opInputComaSimpleFieldProjection)
private opInputComaComplexFieldProjection ::= '{' (opInputFieldProjectionBodyPart ','? )* opInputComaVarProjection? '}'
private opInputComaSimpleFieldProjection ::= opInputComaVarProjection

// op input list
opInputComaListModelProjection ::= '*' '(' opInputComaVarProjection ')' { pin=1 }

// op input map
opInputComaMapModelProjection ::= opInputComaKeyProjection '(' opInputComaVarProjection ')'
opInputComaKeyProjection ::= '[' ']' {pin=1}

// ============= req projections =============

reqParam ::= ';' qid '=' datum
reqAnnotation ::= '!' customParam
private reqParamsAndAnnotations ::= ( reqParam | reqAnnotation )* 

// req output --------------------------------------------------------
// this is based on opInput

reqOutputModelMeta ::= '@' '+'? reqOutputComaModelProjection // no params/annotations on meta?

reqOutputVarPolymorphicTail ::= reqOutputVarSingleTail | reqOutputVarMultiTail
reqOutputVarSingleTail ::= '~' fqnTypeRef reqOutputComaVarProjection
reqOutputVarMultiTail ::= '~' '(' (reqOutputVarMultiTailItem ','?)* ')' {pin=2}
reqOutputVarMultiTailItem ::= fqnTypeRef reqOutputComaVarProjection

//reqOutputFieldProjectionBodyPart ::= customParam

// input projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
// singular tags and fields are allowed in var and record projections. Coma can contain branching

// input trunk part

reqOutputTrunkVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputTrunkSingleTagProjection ) reqOutputVarPolymorphicTail?
reqOutputTrunkSingleTagProjection ::= ( ':' '+'? tagName )? reqParamsAndAnnotations reqOutputTrunkModelProjection reqOutputModelMeta?

//

reqOutputTrunkModelProjection ::= ( reqOutputTrunkRecordOrMapModelProjection
                                  | reqOutputComaRecordModelProjection
                                  | reqOutputComaMapModelProjection
                                  | reqOutputComaListModelProjection
                                  )? {
  extends = reqOutputComaModelProjection
}

// record or map. We can't tell which one it is based on syntax only, need to check with model or op projection
reqOutputTrunkRecordOrMapModelProjection ::= '/' reqOutputTrunkFieldOrKeyProjection { pin=1 }
// this ought to be '+' (datum | qid), but enumDatum would match qid anyways.. todo: fix if enums are eliminated
reqOutputTrunkFieldOrKeyProjection ::= '+'? datum reqParamsAndAnnotations reqOutputTrunkVarProjection

// input coma part

reqOutputComaVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputComaSingleTagProjection ) reqOutputVarPolymorphicTail?
reqOutputComaSingleTagProjection ::= ( ':' '+'? tagName)? reqOutputComaTagProjectionItem
reqOutputComaMultiTagProjection ::= ':' '(' ('+'? tagName reqOutputComaTagProjectionItem ','?)* ')' {pin=2}
reqOutputComaTagProjectionItem ::= reqParamsAndAnnotations reqOutputComaModelProjection reqOutputModelMeta?
//

reqOutputComaModelProjection ::= ( reqOutputComaRecordModelProjection
                                 | reqOutputComaListModelProjection
                                 | reqOutputComaMapModelProjection
                                 )?

// op input record
reqOutputComaRecordModelProjection ::= '(' (reqOutputComaFieldProjection ','?)* ')' { pin=1 }
reqOutputComaFieldProjection ::= '+'? qid reqParamsAndAnnotations reqOutputComaVarProjection

// op input list
reqOutputComaListModelProjection ::= '*' '(' reqOutputComaVarProjection ')' { pin=1 }

// op input map
reqOutputComaMapModelProjection ::= reqOutputComaKeysProjection '(' reqOutputComaVarProjection ')'
reqOutputComaKeysProjection ::= '+'? '[' ( reqOutputComaKeyProjection ','? )* ']' {pin=2}
reqOutputComaKeyProjection ::= datum reqParamsAndAnnotations

// ============= data language =============
// please keep in sync with data language from schema.bnf

dataValue ::= data | datum
private dataTypeSpec ::= fqnTypeRef

data ::= dataTypeSpec? '<' dataEntry* '>' {pin=2}
dataEntry ::= qid ':' datum ','? {pin=2 recoverWhile=dataValueRecover}

datum ::= recordDatum | mapDatum | listDatum | primitiveDatum | enumDatum | nullDatum

recordDatum ::= dataTypeSpec? '{' recordDatumEntry* '}' {pin=2 extends=datum}
recordDatumEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

mapDatum ::= dataTypeSpec? '(' mapDatumEntry* ')' {pin=2 extends=datum}
mapDatumEntry ::= datum ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

listDatum ::= dataTypeSpec? '[' (dataValue ','?)* ']' {pin=2 extends=datum}

primitiveDatum ::= (dataTypeSpec '@')? (string | number | boolean) {extends=datum}

enumDatum ::= qid {extends=datum}

nullDatum ::= (dataTypeSpec '@')? 'null' {extends=datum}

private dataValueRecover ::= ! ( qid | primitiveDatum | '}' | ')' | '>' | ']' | ',' )
