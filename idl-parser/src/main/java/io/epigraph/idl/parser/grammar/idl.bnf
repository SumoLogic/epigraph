{
  parserClass="io.epigraph.idl.parser.IdlParser"

  elementTypeHolderClass="io.epigraph.idl.lexer.IdlElementTypes"
  elementTypePrefix="I_"
  elementTypeClass="io.epigraph.idl.lexer.IdlElementType"
  tokenTypeClass="io.epigraph.idl.lexer.IdlElementType"

  psiClassPrefix="Idl"
  psiImplClassSuffix="Impl"
  psiPackage="io.epigraph.idl.parser.psi"
  psiImplPackage="io.epigraph.idl.parser.psi.impl"
  psiImplUtilClass="io.epigraph.idl.parser.psi.impl.IdlPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    META = 'meta'
    LIST = 'list'
    MAP = 'map'
    FORBIDDEN = 'forbidden'
    REQUIRED = 'required'
    DEFAULT = 'default'

    RESOURCE = 'resource'
    READ = 'READ'
    CREATE = 'CREATE'
    UPDATE = 'UPDATE'
    DELETE = 'DELETE'
    CUSTOM = 'CUSTOM'
    INPUT = 'input'
    OUTPUT = 'output'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    SEMICOLON = ';'
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    TILDA = '~'
    STAR = '*'
    PLUS = '+'
    AT = '@'
    HASH = '#'
    UNDERSCORE = '_'
    BANG = '!'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'

    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]

  pin(".*Body") = 1
}

root ::= namespaceDecl imports resourceDefs

// either quoted or unquoted id
qid ::= id {
//   methods=[getName setName getCanonicalName]
   methods=[getName getCanonicalName]
}

imports ::= importStatement*
importStatement ::= 'import' qn {pin=1 recoverWhile="importRecover"}

namespaceDecl ::= 'namespace' qn namespaceBody? {
//  methods=[getFqn2 toString]
//  stubClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStub"
//  elementTypeClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStubElementType"
  pin=1
  recoverWhile="namespaceDeclRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= annotation // | ...

qnSegment ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
qn ::= qnSegment ('.' qnSegment)* {
  methods=[getQn]
}

// types --------
typeRef ::= qnTypeRef | anonList | anonMap {name="type"}
qnTypeRef ::= qn {
  extends=typeRef
//  methods=[resolve] extends="typeRef"
}

anonList ::= 'list' '[' valueTypeRef ']' {pin=1 extends=typeRef }
anonMap ::= 'map' '[' typeRef ',' valueTypeRef ']' {pin=1 extends=typeRef }

valueTypeRef ::= typeRef defaultOverride?
defaultOverride ::= 'default' varTagRef
varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[setName getNameIdentifier getReference]
}

// -----------

//varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
////  methods=[setName getNameIdentifier getReference]
//}

annotation ::= qid '=' dataValue {
  name="custom annotation"
//  implements="com.intellij.psi.PsiNamedElement"
//  methods = [getName setName getNameIdentifier]
  pin = 2
}

private namespaceDeclRecover ::= ! ('import' | 'resource' )
private importRecover ::= namespaceDeclRecover

tagName ::= qid | '_' // `_` is default tag

// ============= resources =============

private resourceDefs ::= (resourceDef ','?)*
resourceDef ::= 'resource' qid resourceType resourceDefBody
resourceType ::= ':' valueTypeRef

private resourceDefBody ::= '{' (resourceDefPart ','?)* '}'
private resourceDefPart ::= operationDef { recoverWhile = operationBodyRecover }

operationName ::= 'default' | qid
operationInput ::= 'input' opInputTrunkVarProjection {pin=1}
operationOutput ::= 'output' opOutputVarProjection {pin=1}

operationDef ::= readOperationDef | createOperationDef | updateOperationDef | customOperationDef

readOperationDef ::= operationName? 'READ' readOperationBody {pin=2}
private readOperationBody ::= '{' (readOperationBodyPart ','?)* '}'
readOperationBodyPart ::= operationOutput | opParam | annotation {
  recoverWhile = operationBodyRecover
}

createOperationDef ::= operationName? 'CREATE' createOperationBody {pin=2}
private createOperationBody ::= '{' (createOperationBodyPart ','?)* '}'
createOperationBodyPart ::= operationInput | operationOutput | opParam | annotation {
  recoverWhile = operationBodyRecover
}

updateOperationDef ::= operationName? 'UPDATE' updateOperationBody {pin=2}
private updateOperationBody ::= '{' (updateOperationBodyPart ','?)* '}'
updateOperationBodyPart ::= operationInput | operationOutput | opParam | annotation {
  recoverWhile = operationBodyRecover
}

// todo DELETE

customOperationDef ::= qid 'CUSTOM' customOperationBody {pin=2} // todo specify verb?
private customOperationBody ::= '{' (customOperationBodyPart ','?)* '}'
customOperationBodyPart ::= operationInput | operationOutput | opParam | annotation {
  recoverWhile = operationBodyRecover
}

private operationBodyRecover ::= ! ( '}' | ',' | ';' | 'input' | 'output' | (id '=') |
  (id? ('READ' | 'CREATE' | 'UPDATE' | 'DELETE') ) )

// ============= op projections =============

opParam ::= ';' '+'? qid ':' typeRef opInputComaModelProjection opParamDefault? opParamBody? { pin = 1 }
private opParamDefault ::= '=' datum { pin=1 }
private opParamBody ::= '{' ( opParamBodyPart ','? )* '}'
private opParamBodyPart ::= annotation

// output --------------------------------------------------------

opOutputModelMeta ::= 'meta' ':' '+'? opOutputModelProjection

opOutputVarProjection ::= ( opOutputMultiTagProjection | opOutputSingleTagProjection ) opOutputVarPolymorphicTail?

opOutputMultiTagProjection ::= ':' '(' (opOutputMultiTagProjectionItem ','?)* ')' {pin=2}
opOutputSingleTagProjection ::= ( ':' '+'? tagName)? (opOutputComplexTagProjection | opOutputSimpleTagProjection )
opOutputMultiTagProjectionItem ::= '+'? tagName ( opOutputComplexTagProjection | opOutputSimpleTagProjection )

private opOutputSimpleTagProjection ::= opOutputModelProjection
private opOutputComplexTagProjection ::= '{' (opOutputModelProperty ','?)* opOutputModelProjection '}' {pin=1}

//
opOutputVarPolymorphicTail ::= opOutputVarSingleTail | opOutputVarMultiTail
opOutputVarSingleTail ::= '~' typeRef opOutputVarProjection
opOutputVarMultiTail ::= '~' '(' (opOutputVarMultiTailItem ','?)* ')' {pin=2}
opOutputVarMultiTailItem ::= typeRef opOutputVarProjection

opOutputModelProperty ::= opParam | annotation | opOutputModelMeta

opOutputModelProjection ::= ( opOutputRecordModelProjection
                            | opOutputListModelProjection
                            | opOutputMapModelProjection
//                          | opOutputEnumModelProjection
//                          | opOutputPrimitiveModelProjection
                            )?

// op output record
opOutputRecordModelProjection ::= '(' (opOutputFieldProjection ','?)* ')' { pin=1 }
opOutputFieldProjection ::= '+'? qid (opOutputComplexFieldProjection | opOutputSimpleFieldProjection)
private opOutputComplexFieldProjection ::= '{' (opOutputFieldProjectionBodyPart ','? )* opOutputVarProjection? '}'
private opOutputSimpleFieldProjection ::= opOutputVarProjection
opOutputFieldProjectionBodyPart ::= opParam | annotation

// op output list
opOutputListModelProjection ::= '*' '(' opOutputVarProjection ')' { pin=1 }

// op output map
opOutputMapModelProjection ::= opOutputKeyProjection '(' opOutputVarProjection ')' { pin=1 }
opOutputKeyProjection ::= '[' opOutputKeyProjectionInt ']' {pin=1}
private opOutputKeyProjectionInt ::= ('required' ','?| 'forbidden' ','?)? (opOutputKeyProjectionPart ','?)* {
  recoverWhile = opOutputKeyProjectionRecover
}
opOutputKeyProjectionPart ::= opParam | annotation
private opOutputKeyProjectionRecover ::= ! ( ']' )

//opOutputPrimitiveModelProjection ::= 'primitive' // ?
//opOutputEnumModelProjection ::= 'enum' // ?

// input --------------------------------------------------------

opInputModelProperty ::= opInputDefaultValue | annotation | opInputModelMeta {recoverWhile = opInputModelPropertyRecover}
private opInputModelPropertyRecover ::= ! ( '}' )
opInputDefaultValue ::= 'default' ':' datum {pin=1}

opInputModelMeta ::= 'meta' ':' '+'? opInputComaModelProjection

opInputVarPolymorphicTail ::= opInputVarSingleTail | opInputVarMultiTail
opInputVarSingleTail ::= '~' typeRef opInputComaVarProjection
opInputVarMultiTail ::= '~' '(' (opInputVarMultiTailItem ','?)* ')' {pin=2}
// todo: recovery. Commented out one breaks parsing tests
opInputVarMultiTailItem ::= typeRef opInputComaVarProjection // {recoverWhile = opInputVarMultiTailItemRecover}
//private opInputVarMultiTailItemRecover ::= ! ( ')' )

// todo: recovery. Commented out one breaks parsing tests
opInputFieldProjectionBodyPart ::= annotation // {recoverWhile=opInputFieldProjectionBodyPartRecover}
//private opInputFieldProjectionBodyPartRecover ::= ! ( '}' )

// input projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
// singular tags and fields are allowed in var and record projections. Coma can contain branching

// input trunk part

opInputTrunkVarProjection ::= ( opInputComaMultiTagProjection | opInputTrunkSingleTagProjection ) opInputVarPolymorphicTail?
opInputTrunkSingleTagProjection ::= ( ':' '+'? tagName)? (opInputTrunkComplexSingleTagProjection | opInputTrunkSimpleSingleTagProjection )
private opInputTrunkSimpleSingleTagProjection ::= opInputTrunkModelProjection
private opInputTrunkComplexSingleTagProjection ::= '{' (opInputModelProperty ','?)* opInputTrunkModelProjection '}' {pin=1}

//

opInputTrunkModelProjection ::= ( opInputTrunkRecordModelProjection
                                | opInputComaRecordModelProjection
                                | opInputComaListModelProjection
                                | opInputComaMapModelProjection
                                )? {
  extends = opInputComaModelProjection
}

// op input record trunk
opInputTrunkRecordModelProjection ::= '/' opInputTrunkFieldProjection { pin=1 }
opInputTrunkFieldProjection ::= '+'? qid (opInputTrunkComplexFieldProjection | opInputTrunkSimpleFieldProjection)
private opInputTrunkComplexFieldProjection ::= '{' (opInputFieldProjectionBodyPart ','? )* opInputTrunkVarProjection? '}'
private opInputTrunkSimpleFieldProjection ::= opInputTrunkVarProjection

// input coma part

opInputComaVarProjection ::= ( opInputComaMultiTagProjection | opInputComaSingleTagProjection ) opInputVarPolymorphicTail?
opInputComaMultiTagProjection ::= ':' '(' (opInputComaMultiTagProjectionItem ','?)* ')' {pin=2}
opInputComaSingleTagProjection ::= ( ':' '+'? tagName)? (opInputComaComplexTagProjection | opInputComaSimpleTagProjection )
opInputComaMultiTagProjectionItem ::= '+'? tagName ( opInputComaComplexTagProjection | opInputComaSimpleTagProjection )

private opInputComaSimpleTagProjection ::= opInputComaModelProjection
private opInputComaComplexTagProjection ::= '{' (opInputModelProperty ','?)* opInputComaModelProjection '}' {pin=1}
//

opInputComaModelProjection ::= ( opInputComaRecordModelProjection
                               | opInputComaListModelProjection
                               | opInputComaMapModelProjection
                               )?

// op input record
opInputComaRecordModelProjection ::= '(' (opInputComaFieldProjection ','?)* ')' { pin=1 }
opInputComaFieldProjection ::= '+'? qid (opInputComaComplexFieldProjection | opInputComaSimpleFieldProjection)
private opInputComaComplexFieldProjection ::= '{' (opInputFieldProjectionBodyPart ','? )* opInputComaVarProjection? '}'
private opInputComaSimpleFieldProjection ::= opInputComaVarProjection

// op input list
opInputComaListModelProjection ::= '*' '(' opInputComaVarProjection ')' { pin=1 }

// op input map
opInputComaMapModelProjection ::= opInputComaKeyProjection '(' opInputComaVarProjection ')'
opInputComaKeyProjection ::= '[' ']' {pin=1}

// ============= req projections =============

// TODO this must be moved to a separate client definition language

reqParam ::= ';' qid '=' datum
reqAnnotation ::= '!' annotation
private reqParamsAndAnnotations ::= ( reqParam | reqAnnotation )* 

// req output --------------------------------------------------------
// this is based on opInput

reqOutputModelMeta ::= '@' '+'? reqOutputComaModelProjection // no params/annotations on meta?

reqOutputVarPolymorphicTail ::= reqOutputVarSingleTail | reqOutputVarMultiTail
reqOutputVarSingleTail ::= '~' typeRef reqOutputComaVarProjection
reqOutputVarMultiTail ::= '~' '(' (reqOutputVarMultiTailItem ','?)* ')' {pin=2}
reqOutputVarMultiTailItem ::= typeRef reqOutputComaVarProjection

// input projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
// singular tags and fields are allowed in var and record projections. Coma can contain branching

// req output trunk part

reqOutputTrunkVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputTrunkSingleTagProjection ) reqOutputVarPolymorphicTail?
reqOutputTrunkSingleTagProjection ::= ( ':' '+'? tagName )? reqParamsAndAnnotations reqOutputTrunkModelProjection reqOutputModelMeta?

//

reqOutputTrunkModelProjection ::= ( reqOutputTrunkRecordModelProjection
                                  | reqOutputTrunkMapModelProjection
                                  | reqOutputComaRecordModelProjection
                                  | reqOutputComaMapModelProjection
                                  | reqOutputComaListModelProjection
                                  )? {
  extends = reqOutputComaModelProjection
}

reqOutputTrunkRecordModelProjection ::= '/' '+'? qid reqOutputTrunkFieldProjection {pin=3}
reqOutputTrunkFieldProjection ::= reqParamsAndAnnotations reqOutputTrunkVarProjection

reqOutputTrunkMapModelProjection ::= '/' reqOutputTrunkKeyProjection
private reqOutputTrunkKeyProjection ::= '+'? datum reqParamsAndAnnotations reqOutputTrunkVarProjection {pin=2}

// req output coma part

reqOutputComaVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputComaSingleTagProjection ) reqOutputVarPolymorphicTail?
reqOutputComaSingleTagProjection ::= ( ':' '+'? tagName)? reqOutputComaTagProjectionItem
reqOutputComaMultiTagProjection ::= ':' '(' (reqOutputComaMultiTagProjectionItem ','?)* ')' {pin=2}
reqOutputComaMultiTagProjectionItem ::= '+'? tagName reqOutputComaTagProjectionItem
private reqOutputComaTagProjectionItem ::= reqParamsAndAnnotations reqOutputComaModelProjection reqOutputModelMeta?
//

reqOutputComaModelProjection ::= ( reqOutputComaRecordModelProjection
                                 | reqOutputComaListModelProjection
                                 | reqOutputComaMapModelProjection
                                 )?

// req output record
reqOutputComaRecordModelProjection ::= '(' (reqOutputComaFieldProjection ','?)* ')' { pin=1 }
reqOutputComaFieldProjection ::= '+'? qid reqParamsAndAnnotations reqOutputComaVarProjection

// req output list
reqOutputComaListModelProjection ::= '*' ( '(' reqOutputComaVarProjection ')' )? { pin=1 }

// req output map
reqOutputComaMapModelProjection ::= reqOutputComaKeysProjection ( '(' reqOutputComaVarProjection ')' )?
reqOutputComaKeysProjection ::= ( '+'? ( '[' ( reqOutputComaKeyProjection ','? )* ']' ) | ( '[' '*' ']' ) )
reqOutputComaKeyProjection ::= datum reqParamsAndAnnotations

// ============= data language =============
// please keep in sync with data language from schema.bnf and url.bnf

dataValue ::= data | datum
private dataTypeSpec ::= typeRef

data ::= dataTypeSpec? '<' dataEntry* '>' {pin=2}
dataEntry ::= qid ':' datum ','? {pin=2 recoverWhile=dataValueRecover}

datum ::= recordDatum | mapDatum | listDatum | primitiveDatum | enumDatum | nullDatum

recordDatum ::= dataTypeSpec? '{' recordDatumEntry* '}' {pin=2 extends=datum}
recordDatumEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

mapDatum ::= dataTypeSpec? '(' mapDatumEntry* ')' {pin=2 extends=datum}
mapDatumEntry ::= datum ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

listDatum ::= dataTypeSpec? '[' (dataValue ','?)* ']' {pin=2 extends=datum}

primitiveDatum ::= (dataTypeSpec '@')? (string | number | boolean) {extends=datum}

enumDatum ::= '#' qid {extends=datum}

nullDatum ::= (dataTypeSpec '@')? 'null' {extends=datum}

private dataValueRecover ::= ! ( '#' | qid | primitiveDatum | '}' | ')' | '>' | ']' | ',' )
