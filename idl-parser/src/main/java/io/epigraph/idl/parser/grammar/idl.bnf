{
  parserClass="io.epigraph.idl.parser.IdlParser"

  elementTypeHolderClass="io.epigraph.idl.lexer.IdlElementTypes"
  elementTypePrefix="I_"
  elementTypeClass="io.epigraph.idl.lexer.IdlElementType"
  tokenTypeClass="io.epigraph.idl.lexer.IdlElementType"

  psiClassPrefix="Idl"
  psiImplClassSuffix="Impl"
  psiPackage="io.epigraph.idl.parser.psi"
  psiImplPackage="io.epigraph.idl.parser.psi.impl"
  psiImplUtilClass="io.epigraph.idl.parser.psi.impl.IdlPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    FORBIDDEN = 'forbidden'
    REQURIED = 'required'
    PARAMETERS = 'parameters'
    DEFAULT = 'default'
//    PRIMITIVE = 'primitive'
//    ENUM = 'enum'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    TILDA = '~'
    STAR = '*'
    PLUS = '+'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'

    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]

  pin(".*Body") = 1
}

// TODO proper root
root ::= namespaceDecl imports opOutputVarProjection

// either quoted or unquoted id
qid ::= id {
//   methods=[getName setName getCanonicalName]
   methods=[getName getCanonicalName]
}

imports ::= importStatement*
importStatement ::= 'import' fqn {pin=1 recoverWhile="importRecover"}

namespaceDecl ::= 'namespace' fqn namespaceBody? {
//  methods=[getFqn2 toString]
//  stubClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStub"
//  elementTypeClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStubElementType"
  pin=1
  recoverWhile="namespaceDeclRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqnSegment ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
fqn ::= fqnSegment ('.' fqnSegment)* {
  methods=[getFqn]
}

fqnTypeRef ::= fqn {
  name="type"
//  methods=[resolve] extends="typeRef"
}

//varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
////  methods=[setName getNameIdentifier getReference]
//}

customParam ::= qid '=' dataValue {
  name="custom attribute"
//  implements="com.intellij.psi.PsiNamedElement"
//  methods = [getName setName getNameIdentifier]
  pin = 2
}

private namespaceDeclRecover ::= ! ('import' | 'namespace' )
private importRecover ::= namespaceDeclRecover

// ------------- op projections -------------

opParamProjection ::= qid ':' opInputModelProjection
opParameters ::= 'parameters' ':' '{' (opParamProjection ','?)* '}'

// output

opOutputVarProjection ::= ( opOutputMultiTagProjection | opOutputSingleTagProjection ) opOutputVarPolymorphicTail?
opOutputSingleTagProjection ::= ( ':' '+'? qid )? opOutputModelProjection
opOutputMultiTagProjection ::= ':' '(' (opOutputMultiTagProjectionItem ','?)* ')' {pin=2}
opOutputMultiTagProjectionItem ::= '+'? qid opOutputModelProjection
//
opOutputVarPolymorphicTail ::= opOutputVarSingleTail | opOutputVarMultiTail
opOutputVarSingleTail ::= '~' fqnTypeRef opOutputVarProjection
opOutputVarMultiTail ::= '~' '(' (opOutputVarMultiTailItem ','?)* ')' {pin=2}
opOutputVarMultiTailItem ::= fqnTypeRef opOutputVarProjection

opOutputModelProjection ::= '+'? ( opOutputRecordModelProjection
                                 | opOutputListModelProjection
                                 | opOutputMapModelProjection
//                               | opOutputEnumModelProjection
//                               | opOutputPrimitiveModelProjection
                                 )? opOutputModelProjectionBody?

opOutputModelProjectionBody ::= '{' (opOutputModelProjectionBodyPart ','?)* '}'
opOutputModelProjectionBodyPart ::= opParameters | customParam

// op output record
opOutputRecordModelProjection ::= '(' (opOutputFieldProjection ','?)* ')' {
  pin=1
  extends=opOutputModelProjection
}
opOutputFieldProjection ::= '+'? qid opOutputFieldProjectionBody? opOutputVarProjection?
opOutputFieldProjectionBody ::= '{' (opOutputFieldProjectionBodyPart ','?)* '}'
opOutputFieldProjectionBodyPart ::= opParameters | customParam

// files : Files default FileList *(..) ~FileList2(..)
// op output list
opOutputListModelProjection ::= '*' opOutputVarProjection {
  pin=1
  extends=opOutputModelProjection
}

opOutputMapModelProjection ::= opOutputKeyProjection '*' opOutputVarProjection {
  pin=1
  extends=opOutputModelProjection
}
opOutputKeyProjection ::= '[' (opOutputKeyProjectionPart ','?)* ']' {pin=1}
opOutputKeyProjectionPart ::= 'forbidden' | 'required' | opParameters | customParam

//opOutputPrimitiveModelProjection ::= 'primitive' // ?
//opOutputEnumModelProjection ::= 'enum' // ?

// input

opInputModelProjection ::= id // todo

// ------------- data language -------------

//dataValue ::= dataTypeSpec? (dataVar | dataVarValue)
//private dataVarValue ::= dataRecord | dataMap | dataList | dataEnum | dataPrimitiveValue | 'null'
//private dataTypeSpec ::= ( fqnTypeRef '/' )*
dataValue ::= dataTypeSpec? (dataVar | varValue)
private dataVarValue ::= dataTypeSpec? varValue   // because we want (foo/bar:baz) ?
private varValue ::= dataRecord | dataMap | dataList | dataEnum | dataPrimitive | 'null'
private dataTypeSpec ::= ( fqnTypeRef '/' )* // TODO we only need single type spec now

dataVar ::= '<' dataVarEntry* '>' {pin=1 extends=dataValue}
dataVarEntry ::= qid ':' dataVarValue ','? {pin=2 recoverWhile=dataValueRecover}

dataRecord ::= '{' dataRecordEntry* '}' {pin=1 extends=dataValue}
dataRecordEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

dataMap ::= '(' dataMapEntry* ')' {pin=1 extends=dataValue}
dataMapEntry ::= dataVarValue ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

dataList ::= '[' (dataValue ','?)* ']' {pin=1 extends=dataValue}

dataEnum ::= qid {extends=dataValue}

dataPrimitive ::= string | number | boolean // | opOutputVarProjection

private dataValueRecover ::= ! ( qid | dataPrimitive | '}' | ')' | '>' | ']' | ',' )
