{
  parserClass="io.epigraph.idl.parser.IdlParser"

  elementTypeHolderClass="io.epigraph.idl.lexer.IdlElementTypes"
  elementTypePrefix="I_"
  elementTypeClass="io.epigraph.idl.lexer.IdlElementType"
  tokenTypeClass="io.epigraph.idl.lexer.IdlElementType"

  psiClassPrefix="Idl"
  psiImplClassSuffix="Impl"
  psiPackage="io.epigraph.idl.parser.psi"
  psiImplPackage="io.epigraph.idl.parser.psi.impl"
  psiImplUtilClass="io.epigraph.idl.parser.psi.impl.IdlPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    META = 'meta'
    LIST = 'list'
    MAP = 'map'
    FORBIDDEN = 'forbidden'
    REQUIRED = 'required'
    DEFAULT = 'default'

    RESOURCE = 'resource'

    // http methods
    GET = 'GET'
    POST = 'POST'
    PUT = 'PUT'
    DELETE = 'DELETE'

    // operation types
    READ = 'READ'
    CREATE = 'CREATE'
    UPDATE = 'UPDATE'
    // DELETE = 'DELETE'
    CUSTOM = 'CUSTOM'

    METHOD = 'method'
    INPUT_TYPE = 'inputType'
    INPUT_PROJECTION = 'inputProjection'
    OUTPUT_TYPE = 'outputType'
    OUTPUT_PROJECTION = 'outputProjection'
    DELETE_PROJECTION = 'deleteProjection'
    PATH = 'path'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    SEMICOLON = ';'
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    TILDA = '~'
    STAR = '*'
    PLUS = '+'
    AT = '@'
    HASH = '#'
    UNDERSCORE = '_'
    BANG = '!'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'

    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]

  pin(".*Body") = 1
}

root ::= namespaceDecl imports resourceDefs

// either quoted or unquoted id
qid ::= id {
//   methods=[getName setName getCanonicalName]
   methods=[getName getCanonicalName]
}

imports ::= importStatement*
importStatement ::= 'import' qn {pin=1 recoverWhile="importRecover"}

namespaceDecl ::= 'namespace' qn namespaceBody? {
//  methods=[getFqn2 toString]
//  stubClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStub"
//  elementTypeClass="io.epigraph.schema.parser.psi.stubs.SchemaNamespaceDeclStubElementType"
  pin=1
  recoverWhile="namespaceDeclRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= annotation // | ...

qnSegment ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
qn ::= qnSegment ('.' qnSegment)* {
  methods=[getQn]
}

// types --------
typeRef ::= qnTypeRef | anonList | anonMap {name="type"}
qnTypeRef ::= qn {
  extends=typeRef
//  methods=[resolve] extends="typeRef"
}

anonList ::= 'list' '[' valueTypeRef ']' {pin=1 extends=typeRef }
anonMap ::= 'map' '[' typeRef ',' valueTypeRef ']' {pin=1 extends=typeRef }

valueTypeRef ::= typeRef defaultOverride?
defaultOverride ::= 'default' varTagRef
varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
//  methods=[setName getNameIdentifier getReference]
}

// -----------

//varTagRef ::= qid {
//  implements="com.intellij.psi.PsiNameIdentifierOwner"
////  methods=[setName getNameIdentifier getReference]
//}

annotation ::= qid '=' dataValue {
  name="custom annotation"
//  implements="com.intellij.psi.PsiNamedElement"
//  methods = [getName setName getNameIdentifier]
  pin = 2
}

private namespaceDeclRecover ::= ! ('import' | 'resource' )
private importRecover ::= namespaceDeclRecover

tagName ::= qid | '_' // `_` is default tag

// ============= resources =============

private resourceDefs ::= (resourceDef ','?)*
resourceDef ::= 'resource' resourceName resourceType resourceDefBody
resourceName ::= qid
resourceType ::= ':' valueTypeRef

private resourceDefBody ::= '{' (resourceDefPart ','?)* '}'
private resourceDefPart ::= operationDef { recoverWhile = operationBodyRecover }

/*
resource users map[String,User] {
  CREATE {
    ; foo : String = "sf"
    doc = "sdf"

    path * { ;foo : Int, name = "id" } : record / bestFriend
    // or path $id { ;foo : Int } : record / bestFriend // todo give name to path and op key(s)
    inputType Foo
    inputProjection (..)
    outputType Bar
    outputProjection (..)
  }
}
 */

// operation def parts
operationName ::= 'default' | qid
operationMethod ::= 'method' ('GET' | 'POST' | 'PUT' | 'DELETE') // add 'PATCH' too?
operationPath ::= 'path' opFieldPath {pin=1}
operationInputType ::= 'inputType' typeRef {pin=2}
operationInputProjection ::= 'inputProjection' opInputModelProjection {pin=2}
operationOutputType ::= 'outputType' valueTypeRef {pin=2}
operationOutputProjection ::= 'outputProjection' opOutputFieldProjection {pin=2}
operationDeleteProjection ::= 'deleteProjection' opDeleteFieldProjection {pin=2}

operationDef ::= createOperationDef | readOperationDef | updateOperationDef | deleteOperationDef | customOperationDef

createOperationDef ::= operationName? 'CREATE' createOperationBody {pin=2}
private createOperationBody ::= '{' (createOperationBodyPart ','?)* '}'
createOperationBodyPart ::= operationPath |
                            operationInputType |
                            operationInputProjection |
                            operationOutputType |
                            operationOutputProjection |
                            annotation {
  recoverWhile = operationBodyRecover
}

readOperationDef ::= operationName? 'READ' readOperationBody {pin=2}
private readOperationBody ::= '{' (readOperationBodyPart ','?)* '}'
readOperationBodyPart ::= operationPath |
                          operationOutputProjection |
                          annotation {
  recoverWhile = operationBodyRecover
}

updateOperationDef ::= operationName? 'UPDATE' updateOperationBody {pin=2}
private updateOperationBody ::= '{' (updateOperationBodyPart ','?)* '}'
updateOperationBodyPart ::= operationPath |
                            operationInputType |
                            operationInputProjection |
                            operationOutputType |
                            operationOutputProjection | 
                            annotation {
  recoverWhile = operationBodyRecover
}

deleteOperationDef ::= operationName? 'DELETE' deleteOperationBody {pin=2}
private deleteOperationBody ::= '{' (deleteOperationBodyPart ','?)* '}'
deleteOperationBodyPart ::= operationPath |
                            operationDeleteProjection |
                            operationOutputType |
                            operationOutputProjection |
                            annotation {
  recoverWhile = operationBodyRecover
}

customOperationDef ::= operationName 'CUSTOM' customOperationBody {pin=2} // todo specify verb?
private customOperationBody ::= '{' (customOperationBodyPart ','?)* '}'
customOperationBodyPart ::= operationMethod |
                            operationPath |
                            operationInputType |
                            operationInputProjection |
                            operationOutputType |
                            operationOutputProjection |
                            annotation {
  recoverWhile = operationBodyRecover
}

private operationBodyRecover ::= ! ( '}' | ',' |
  'method' | 'inputType' | 'inputProjection' | 'outputType' | 'outputProjection' | 'deleteProjection' | 'path' |
  (id '=') | (id? ('READ' | 'CREATE' | 'UPDATE' | 'DELETE' | 'CUSTOM') ) )

// ============= op projections =============

opParam ::= ';' '+'? qid ':' typeRef opInputModelProjection opParamDefault? opParamBody? { pin = 1 }
private opParamDefault ::= '=' datum { pin=1 }
private opParamBody ::= '{' ( opParamBodyPart ','? )* '}'
private opParamBodyPart ::= annotation

// op path --------------------------------------------------------

// no tails, no branching, no meta

// :tag / field / * / field
// :tag { ;foo:String } / field { ;foo:String } / * { ;foo:String }

opVarPath ::= ( ':' tagName)? opVarPathBody? opModelPath
private opVarPathBody ::= '{' (opModelPathProperty ','?)* '}' {pin=1}

opModelPathProperty ::= opParam | annotation

opModelPath ::= ( opRecordModelPath
                | opMapModelPath
                )?

// op record path
opRecordModelPath ::= '/' opFieldPathEntry
opFieldPathEntry ::= qid opFieldPath
opFieldPath ::= opFieldPathBody? opVarPath {pin=1}
private opFieldPathBody ::= '{' (opFieldPathBodyPart ','? )* '}'
opFieldPathBodyPart ::= opParam | annotation

// op map path
opMapModelPath ::= '/' opPathKeyProjection opVarPath {pin=2}
opPathKeyProjection ::= '.' opPathKeyProjectionBody? {pin=1}
opPathKeyProjectionBody ::= '{' (opPathKeyProjectionPart ','?)*  '}' {pin=1}
opPathKeyProjectionPart ::= opParam | annotation

// output --------------------------------------------------------

opOutputModelMeta ::= 'meta' ':' '+'? opOutputModelProjection

opOutputVarProjection ::= ( opOutputMultiTagProjection | opOutputSingleTagProjection ) opOutputVarPolymorphicTail?

opOutputMultiTagProjection ::= ':' '(' (opOutputMultiTagProjectionItem ','?)* ')' {pin=2}
opOutputSingleTagProjection ::= ( ':' '+'? tagName)? (opOutputComplexTagProjection | opOutputSimpleTagProjection )
opOutputMultiTagProjectionItem ::= '+'? tagName ( opOutputComplexTagProjection | opOutputSimpleTagProjection )

private opOutputSimpleTagProjection ::= opOutputModelProjection
private opOutputComplexTagProjection ::= '{' (opOutputModelProperty ','?)* '}' opOutputModelProjection {pin=1}

//
opOutputVarPolymorphicTail ::= opOutputVarSingleTail | opOutputVarMultiTail
opOutputVarSingleTail ::= '~' typeRef opOutputVarProjection
opOutputVarMultiTail ::= '~' '(' (opOutputVarMultiTailItem ','?)* ')' {pin=2}
opOutputVarMultiTailItem ::= typeRef opOutputVarProjection

opOutputModelProperty ::= opParam | annotation | opOutputModelMeta

opOutputModelProjection ::= ( opOutputRecordModelProjection
                            | opOutputListModelProjection
                            | opOutputMapModelProjection
                            )?

// op output record
opOutputRecordModelProjection ::= '(' (opOutputFieldProjectionEntry ','?)* ')' { pin=1 }
opOutputFieldProjectionEntry ::= '+'? qid opOutputFieldProjection
opOutputFieldProjection ::= (opOutputComplexFieldProjection | opOutputSimpleFieldProjection)
private opOutputComplexFieldProjection ::= '{' (opOutputFieldProjectionBodyPart ','? )* '}' opOutputVarProjection
private opOutputSimpleFieldProjection ::= opOutputVarProjection
opOutputFieldProjectionBodyPart ::= opParam | annotation

// op output list
opOutputListModelProjection ::= '*' '(' opOutputVarProjection ')' { pin=1 }

// op output map
opOutputMapModelProjection ::= opOutputKeyProjection '(' opOutputVarProjection ')' { pin=1 }
opOutputKeyProjection ::= '[' opOutputKeyProjectionInt ']' {pin=1}
private opOutputKeyProjectionInt ::= ('required' ','?| 'forbidden' ','?)? (opOutputKeyProjectionPart ','?)* {
  recoverWhile = opOutputKeyProjectionRecover
}
opOutputKeyProjectionPart ::= opParam | annotation
private opOutputKeyProjectionRecover ::= ! ( ']' )

// input --------------------------------------------------------

opInputModelProperty ::= opInputDefaultValue | annotation | opInputModelMeta {recoverWhile = opInputModelPropertyRecover}
private opInputModelPropertyRecover ::= ! ( '}' )
opInputDefaultValue ::= 'default' ':' datum {pin=1}

opInputModelMeta ::= 'meta' ':' '+'? opInputModelProjection

opInputVarPolymorphicTail ::= opInputVarSingleTail | opInputVarMultiTail
opInputVarSingleTail ::= '~' typeRef opInputVarProjection
opInputVarMultiTail ::= '~' '(' (opInputVarMultiTailItem ','?)* ')' {pin=2}
// todo: recovery. Commented out one breaks parsing tests
opInputVarMultiTailItem ::= typeRef opInputVarProjection // {recoverWhile = opInputVarMultiTailItemRecover}
//private opInputVarMultiTailItemRecover ::= ! ( ')' )

// todo: recovery. Commented out one breaks parsing tests
opInputFieldProjectionBodyPart ::= annotation // {recoverWhile=opInputFieldProjectionBodyPartRecover}
//private opInputFieldProjectionBodyPartRecover ::= ! ( '}' )


opInputVarProjection ::= ( opInputMultiTagProjection | opInputSingleTagProjection ) opInputVarPolymorphicTail?
opInputMultiTagProjection ::= ':' '(' (opInputMultiTagProjectionItem ','?)* ')' {pin=2}
opInputSingleTagProjection ::= ( ':' '+'? tagName)? (opInputComplexTagProjection | opInputSimpleTagProjection )
opInputMultiTagProjectionItem ::= '+'? tagName ( opInputComplexTagProjection | opInputSimpleTagProjection )

private opInputSimpleTagProjection ::= opInputModelProjection
private opInputComplexTagProjection ::= '{' (opInputModelProperty ','?)* opInputModelProjection '}' {pin=1}
//

opInputModelProjection ::= ( opInputRecordModelProjection
                           | opInputListModelProjection
                           | opInputMapModelProjection
                           )?

// op input record
opInputRecordModelProjection ::= '(' (opInputFieldProjection ','?)* ')' { pin=1 }
opInputFieldProjection ::= '+'? qid (opInputComplexFieldProjection | opInputSimpleFieldProjection)
private opInputComplexFieldProjection ::= '{' (opInputFieldProjectionBodyPart ','? )* opInputVarProjection '}'
private opInputSimpleFieldProjection ::= opInputVarProjection

// op input list
opInputListModelProjection ::= '*' '(' opInputVarProjection ')' { pin=1 }

// op input map
opInputMapModelProjection ::= opInputKeyProjection '(' opInputVarProjection ')' { pin=1 }
opInputKeyProjection ::= '[' ']' {pin=1}

// delete --------------------------------------------------------

// can delete current entity or a link to bestFriend:
// + :record ( bestFriend )

// can delete current entity or a bestFriend entity
// + :record ( bestFriend + )

opDeleteVarProjection ::= '+'? ( opDeleteMultiTagProjection | opDeleteSingleTagProjection ) opDeleteVarPolymorphicTail?

opDeleteMultiTagProjection ::= ':' '(' (opDeleteMultiTagProjectionItem ','?)* ')' {pin=2}
opDeleteSingleTagProjection ::= ( ':' tagName)? (opDeleteComplexTagProjection | opDeleteSimpleTagProjection )
opDeleteMultiTagProjectionItem ::= tagName ( opDeleteComplexTagProjection | opDeleteSimpleTagProjection )

private opDeleteSimpleTagProjection ::= opDeleteModelProjection
private opDeleteComplexTagProjection ::= '{' (opDeleteModelProperty ','?)* '}' opDeleteModelProjection {pin=1}

//
opDeleteVarPolymorphicTail ::= opDeleteVarSingleTail | opDeleteVarMultiTail
opDeleteVarSingleTail ::= '~' typeRef opDeleteVarProjection
opDeleteVarMultiTail ::= '~' '(' (opDeleteVarMultiTailItem ','?)* ')' {pin=2}
opDeleteVarMultiTailItem ::= typeRef opDeleteVarProjection

opDeleteModelProperty ::= opParam | annotation

opDeleteModelProjection ::= ( opDeleteRecordModelProjection
                            | opDeleteListModelProjection
                            | opDeleteMapModelProjection
                            )?

// op delete record
opDeleteRecordModelProjection ::= '(' (opDeleteFieldProjectionEntry ','?)* ')' { pin=1 }
opDeleteFieldProjectionEntry ::= qid opDeleteFieldProjection
opDeleteFieldProjection ::= (opDeleteComplexFieldProjection | opDeleteSimpleFieldProjection)
private opDeleteComplexFieldProjection ::= '{' (opDeleteFieldProjectionBodyPart ','? )* '}' opDeleteVarProjection
private opDeleteSimpleFieldProjection ::= opDeleteVarProjection
opDeleteFieldProjectionBodyPart ::= opParam | annotation

// op delete list
opDeleteListModelProjection ::= '*' '(' opDeleteVarProjection ')' { pin=1 }

// op delete map
opDeleteMapModelProjection ::= opDeleteKeyProjection '(' opDeleteVarProjection ')' { pin=1 }
opDeleteKeyProjection ::= '[' opDeleteKeyProjectionInt ']' {pin=1}
private opDeleteKeyProjectionInt ::= ('required' ','?| 'forbidden' ','?)? (opDeleteKeyProjectionPart ','?)* {
  recoverWhile = opDeleteKeyProjectionRecover
}
opDeleteKeyProjectionPart ::= opParam | annotation
private opDeleteKeyProjectionRecover ::= ! ( ']' )

// ============= req projections =============

// TODO this must be moved to a separate client definition language

//reqParam ::= ';' qid '=' datum
//reqAnnotation ::= '!' annotation
//private reqParamsAndAnnotations ::= ( reqParam | reqAnnotation )*
//
//// req output --------------------------------------------------------
//// this is based on opInput
//
//reqOutputModelMeta ::= '@' '+'? reqOutputComaModelProjection // no params/annotations on meta?
//
//reqOutputVarPolymorphicTail ::= reqOutputVarSingleTail | reqOutputVarMultiTail
//reqOutputVarSingleTail ::= '~' typeRef reqOutputComaVarProjection
//reqOutputVarMultiTail ::= '~' '(' (reqOutputVarMultiTailItem ','?)* ')' {pin=2}
//reqOutputVarMultiTailItem ::= typeRef reqOutputComaVarProjection
//
//// input projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
//// singular tags and fields are allowed in var and record projections. Coma can contain branching
//
//// req output trunk part
//
//reqOutputTrunkVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputTrunkSingleTagProjection ) reqOutputVarPolymorphicTail?
//reqOutputTrunkSingleTagProjection ::= ( ':' '+'? tagName )? reqParamsAndAnnotations reqOutputTrunkModelProjection reqOutputModelMeta?
//
////
//
//reqOutputTrunkModelProjection ::= ( reqOutputTrunkRecordModelProjection
//                                  | reqOutputTrunkMapModelProjection
//                                  | reqOutputComaRecordModelProjection
//                                  | reqOutputComaMapModelProjection
//                                  | reqOutputComaListModelProjection
//                                  )? {
//  extends = reqOutputComaModelProjection
//}
//
//reqOutputTrunkRecordModelProjection ::= '/' '+'? qid reqOutputTrunkFieldProjection {pin=3}
//reqOutputTrunkFieldProjection ::= reqParamsAndAnnotations reqOutputTrunkVarProjection
//
//reqOutputTrunkMapModelProjection ::= '/' reqOutputTrunkKeyProjection
//private reqOutputTrunkKeyProjection ::= '+'? datum reqParamsAndAnnotations reqOutputTrunkVarProjection {pin=2}
//
//// req output coma part
//
//reqOutputComaVarProjection ::= ( reqOutputComaMultiTagProjection | reqOutputComaSingleTagProjection ) reqOutputVarPolymorphicTail?
//reqOutputComaSingleTagProjection ::= ( ':' '+'? tagName)? reqOutputComaTagProjectionItem
//reqOutputComaMultiTagProjection ::= ':' '(' (reqOutputComaMultiTagProjectionItem ','?)* ')' {pin=2}
//reqOutputComaMultiTagProjectionItem ::= '+'? tagName reqOutputComaTagProjectionItem
//private reqOutputComaTagProjectionItem ::= reqParamsAndAnnotations reqOutputComaModelProjection reqOutputModelMeta?
////
//
//reqOutputComaModelProjection ::= ( reqOutputComaRecordModelProjection
//                                 | reqOutputComaListModelProjection
//                                 | reqOutputComaMapModelProjection
//                                 )?
//
//// req output record
//reqOutputComaRecordModelProjection ::= '(' (reqOutputComaFieldProjection ','?)* ')' { pin=1 }
//reqOutputComaFieldProjection ::= '+'? qid reqParamsAndAnnotations reqOutputComaVarProjection
//
//// req output list
//reqOutputComaListModelProjection ::= '*' ( '(' reqOutputComaVarProjection ')' )? { pin=1 }
//
//// req output map
//reqOutputComaMapModelProjection ::= reqOutputComaKeysProjection ( '(' reqOutputComaVarProjection ')' )?
//reqOutputComaKeysProjection ::= ( '+'? ( '[' ( reqOutputComaKeyProjection ','? )* ']' ) | ( '[' '*' ']' ) )
//reqOutputComaKeyProjection ::= datum reqParamsAndAnnotations

// ============= data language =============
// please keep in sync with data language from schema.bnf and url.bnf

dataValue ::= data | datum
private dataTypeSpec ::= typeRef

data ::= dataTypeSpec? '<' dataEntry* '>' {pin=2}
dataEntry ::= qid ':' datum ','? {pin=2 recoverWhile=dataValueRecover}

datum ::= recordDatum | mapDatum | listDatum | primitiveDatum | enumDatum | nullDatum

recordDatum ::= dataTypeSpec? '{' recordDatumEntry* '}' {pin=2 extends=datum}
recordDatumEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

mapDatum ::= dataTypeSpec? '(' mapDatumEntry* ')' {pin=2 extends=datum}
mapDatumEntry ::= datum ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

listDatum ::= dataTypeSpec? '[' (dataValue ','?)* ']' {pin=2 extends=datum}

primitiveDatum ::= (dataTypeSpec '@')? (string | number | boolean) {extends=datum}

enumDatum ::= '#' qid {extends=datum}

nullDatum ::= (dataTypeSpec '@')? 'null' {extends=datum}

private dataValueRecover ::= ! ( '#' | qid | primitiveDatum | '}' | ')' | '>' | ']' | ',' )
