/*
 * Copyright 2017 Sumo Logic
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{
  parserClass="ws.epigraph.url.parser.UrlParser"

  elementTypeHolderClass="ws.epigraph.url.lexer.UrlElementTypes"
  elementTypePrefix="U_"
  elementTypeClass="ws.epigraph.url.lexer.UrlElementType"
  tokenTypeClass="ws.epigraph.url.lexer.UrlElementType"

  psiClassPrefix="Url"
  psiImplClassSuffix="Impl"
  psiPackage="ws.epigraph.url.parser.psi"
  psiImplPackage="ws.epigraph.url.parser.psi.impl"
  psiImplUtilClass="ws.epigraph.url.parser.psi.impl.UrlPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    LIST = 'list'
    MAP = 'map'
    DEFAULT = 'default'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    SEMICOLON = ';'
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    TILDA = '~'
    STAR = '*'
    PLUS = '+'
    AT = '@'
    HASH = '#'
    UNDERSCORE = '_'
    BANG = '!'
    DOLLAR = '$'
    QMARK = '?'
    AMP = '&'
    PARAM_NAME = 'regexp:(\p{Alnum}+)'

    space='regexp:\s+'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'

    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]
}

root ::= url

// either quoted or unquoted id
qid ::= id {
   methods=[getName getCanonicalName]
}

qnSegment ::= qid
qn ::= qnSegment ('.' qnSegment)* {
  methods=[getQn]
}

typeRef ::= qnTypeRef | anonList | anonMap {name="type"}
qnTypeRef ::= qn { extends=typeRef }

anonList ::= 'list' '[' valueTypeRef ']' {pin=1 extends=typeRef }
anonMap ::= 'map' '[' typeRef ',' valueTypeRef ']' {pin=1 extends=typeRef }

valueTypeRef ::= typeRef defaultOverride?
defaultOverride ::= 'default' varTagRef {pin=1}
varTagRef ::= qid

annotation ::= qid '=' dataValue {
  name="custom annotation"
  pin = 2
}

tagName ::= qid

// ============= url =============

// this one isn't used actually, sub-parsers for read/create/... are used instead
url ::= readUrl | nonReadUrl | deleteUrl

// todo get rid of requestParms?

// todo rename reqOutput* to req*

// real entry points:
readUrl ::= '/' qid reqOutputTrunkFieldProjection requestParams { // reqFieldPath is part of output projection, will be extracted by psi parser
  extends = "url"
}

nonReadUrl ::= '/' qid reqFieldPath inputProjection? outputProjection? requestParams {
  extends = "url"
}
deleteUrl ::= '/' qid reqFieldPath '<' reqDeleteFieldProjection ('>' reqOutputTrunkFieldProjection)? requestParams {
  extends = "url"
}

inputProjection ::= '<' '+'? reqOutputTrunkFieldProjection { pin = 1 name = "input projection" }
outputProjection ::= '>' '+'? reqOutputTrunkFieldProjection { pin = 1 name = "output projection" }

// todo do we actually need them?
private requestParams ::= requestParam*
requestParam ::= ('?' | '&') PARAM_NAME '=' datum {  // ? vs & nonsense is sorted out in the UrlRequestPsiParser
  pin = 1
  name = "request parameter"
  recoverWhile = requestParamRecover
}
private requestParamRecover ::= ! ( '?' | '&' )


// ============= req output projection =============

reqParam ::= ';' qid '=' datum // todo attach reqInputProjection too?
reqAnnotation ::= '!' annotation
private reqParamsAndAnnotations ::= ( reqParam | reqAnnotation )*

// req path --------------------------------------------------------

// no tails, no branching, no meta

reqVarPath ::= ( ':' tagName)? reqParamsAndAnnotations reqModelPath

reqModelPath ::= ( reqRecordModelPath
                 | reqMapModelPath
                 )?

// req record path
reqRecordModelPath ::= '/' reqFieldPathEntry {pin=2}
reqFieldPathEntry ::= qid reqFieldPath
reqFieldPath ::= /* reqParamsAndAnnotations */ reqVarPath {pin=1}

// req map path
reqMapModelPath ::= '/' reqOutputTrunkKeyProjection reqVarPath {pin=2}

// req output --------------------------------------------------------
// this is based on opInput from schema.bnf

reqOutputStarTagProjection ::= ':' '*' // all tags with empty contents

reqOutputModelMeta ::= '@' '+'? reqOutputComaModelProjection // no params/annotations on meta?

reqOutputVarPolymorphicTail ::= ':' '~' ( reqOutputVarSingleTail | reqOutputVarMultiTail ) {pin=2}
reqOutputVarSingleTail ::= typeRef reqOutputComaVarProjection
reqOutputVarMultiTail ::= '(' (reqOutputVarMultiTailItem ','?)* ')' {pin=1}
reqOutputVarMultiTailItem ::= typeRef reqOutputComaVarProjection

// req projection consists of two parts: trunk and coma. Trunk can't have any branching, i.e. only
// singular tags and fields are allowed in var and record projections. Coma can contain branching

// req output trunk part

reqOutputTrunkVarProjection ::= reqOutputNamedTrunkVarProjection | reqOutputUnnamedOrRefTrunkVarProjection
reqOutputUnnamedOrRefTrunkVarProjection ::= reqOutputTrunkVarProjectionRef | reqOutputUnnamedTrunkVarProjection
reqOutputNamedTrunkVarProjection ::= '$' qid '=' reqOutputUnnamedOrRefTrunkVarProjection {pin = 3}
reqOutputTrunkVarProjectionRef ::= '$' qid {pin = 1}
reqOutputUnnamedTrunkVarProjection ::= ( reqOutputStarTagProjection
                                | reqOutputComaMultiTagProjection
                                | reqOutputTrunkSingleTagProjection
                                ) reqOutputVarPolymorphicTail?

reqOutputTrunkSingleTagProjection ::= ( ( ':' '+'? tagName ) | '+' )? reqOutputTrunkModelProjectionWithProperties reqOutputModelMeta?

private reqOutputTrunkModelProjectionWithProperties ::= reqParamsAndAnnotations reqOutputTrunkModelProjection

//

reqOutputTrunkModelProjection ::= ( reqOutputTrunkRecordModelProjection // no tails on paths
                                  | reqOutputTrunkMapModelProjection
                                  | ( reqOutputComaRecordModelProjection reqOutputModelPolymorphicTail? )
                                  | ( reqOutputComaMapModelProjection reqOutputModelPolymorphicTail? )
                                  | ( reqOutputComaListModelProjection reqOutputModelPolymorphicTail? )
                                  )? {
   extends = reqOutputComaModelProjection
}

reqOutputTrunkRecordModelProjection ::= '/' '+'? qid reqOutputTrunkFieldProjection {pin=3}
reqOutputTrunkFieldProjection ::= /* reqParamsAndAnnotations */ reqOutputTrunkVarProjection

reqOutputTrunkMapModelProjection ::= '/' reqOutputTrunkKeyProjection '+'? reqOutputTrunkVarProjection
private reqOutputTrunkKeyProjection ::= datum reqParamsAndAnnotations {pin=2}

// req output coma part

reqOutputComaVarProjection ::= reqOutputNamedComaVarProjection | reqOutputUnnamedOrRefComaVarProjection
reqOutputUnnamedOrRefComaVarProjection ::= reqOutputComaVarProjectionRef | reqOutputUnnamedComaVarProjection
reqOutputNamedComaVarProjection ::= '$' qid '=' reqOutputUnnamedOrRefComaVarProjection {pin = 3}
reqOutputComaVarProjectionRef ::= '$' qid {pin = 1}
reqOutputUnnamedComaVarProjection ::= ( reqOutputStarTagProjection
                                      | reqOutputComaMultiTagProjection
                                      | reqOutputComaSingleTagProjection
                                      ) reqOutputVarPolymorphicTail?
private reqOutputBracedComaVarProjection ::= '(' reqOutputComaVarProjection ')'

reqOutputComaSingleTagProjection ::= ( ( ':' '+'? tagName) | '+' )? reqOutputComaModelProjectionWithProperties
reqOutputComaMultiTagProjection ::= ':' '(' (reqOutputComaMultiTagProjectionItem ','?)* ')' {pin=2}
reqOutputComaMultiTagProjectionItem ::= '+'? tagName reqOutputComaModelProjectionWithProperties

//
reqOutputModelPolymorphicTail ::= '~' ( reqOutputModelSingleTail | reqOutputModelMultiTail ) // {pin=1}
reqOutputModelSingleTail ::= '+'? typeRef reqOutputComaModelProjectionWithProperties
reqOutputModelMultiTail ::= '(' (reqOutputModelMultiTailItem ','?)* ')' {pin=1}
reqOutputModelMultiTailItem ::= '+'? typeRef reqOutputComaModelProjectionWithProperties

private reqOutputComaModelProjectionWithProperties ::= reqParamsAndAnnotations reqOutputComaModelProjection reqOutputModelMeta?

reqOutputComaModelProjection ::= ( ( reqOutputComaRecordModelProjection
                                   | reqOutputComaListModelProjection
                                   | reqOutputComaMapModelProjection
                                   ) reqOutputModelPolymorphicTail ?
                                 )?

// req output record
reqOutputComaRecordModelProjection ::= '(' ( '*' | ( (reqOutputComaFieldProjection ','?)* ) ) ')' { pin=1 }
reqOutputComaFieldProjection ::= '+'? qid /* reqParamsAndAnnotations */ reqOutputComaVarProjection

// req output list
// todo parser +
reqOutputComaListModelProjection ::= '*' '+'? ( ( reqOutputBracedComaVarProjection | reqOutputComaVarProjection ) )? { pin=1 }

// req output map
// todo parser +
reqOutputComaMapModelProjection ::= reqOutputComaKeysProjection '+'? ( ( reqOutputBracedComaVarProjection | reqOutputComaVarProjection ) )?
reqOutputComaKeysProjection ::= '[' ( '*' | ( ( reqOutputComaKeyProjection ','? )* ) ) ']' {pin=1}
reqOutputComaKeyProjection ::= datum reqParamsAndAnnotations

// req delete --------------------------------------------------------

// reqDeleteModelMeta ::= '@' '+'? reqDeleteModelProjection // no params/annotations on meta?

reqDeleteVarProjection ::= reqDeleteNamedVarProjection | reqDeleteUnnamedOrRefVarProjection
reqDeleteUnnamedOrRefVarProjection ::= reqDeleteVarProjectionRef | reqDeleteUnnamedVarProjection
reqDeleteNamedVarProjection ::= '$' qid '=' reqDeleteUnnamedOrRefVarProjection {pin = 3}
reqDeleteVarProjectionRef ::= '$' qid {pin = 1}
reqDeleteUnnamedVarProjection ::= ( reqDeleteMultiTagProjection | reqDeleteSingleTagProjection ) reqDeleteVarPolymorphicTail?
private reqDeleteBracedVarProjection ::= '(' reqDeleteVarProjection ')'

reqDeleteSingleTagProjection ::= ( ':' tagName)? reqDeleteModelProjectionWithProperties
reqDeleteMultiTagProjection ::= ':' '(' (reqDeleteMultiTagProjectionItem ','?)* ')' {pin=2}
reqDeleteMultiTagProjectionItem ::= tagName reqDeleteModelProjectionWithProperties

reqDeleteVarPolymorphicTail ::= ':' '~' ( reqDeleteVarSingleTail | reqDeleteVarMultiTail ) {pin=2}
reqDeleteVarSingleTail ::= typeRef reqDeleteVarProjection
reqDeleteVarMultiTail ::= '(' (reqDeleteVarMultiTailItem ','?)* ')' {pin=1}
reqDeleteVarMultiTailItem ::= typeRef reqDeleteVarProjection
//
reqDeleteModelPolymorphicTail ::= '~' ( reqDeleteModelSingleTail | reqDeleteModelMultiTail ) // {pin=1}
reqDeleteModelSingleTail ::= typeRef reqDeleteModelProjectionWithProperties
reqDeleteModelMultiTail ::= '(' (reqDeleteModelMultiTailItem ','?)* ')' {pin=1}
reqDeleteModelMultiTailItem ::= typeRef reqDeleteModelProjectionWithProperties

private reqDeleteModelProjectionWithProperties ::= reqParamsAndAnnotations reqDeleteModelProjection // reqDeleteModelMeta?
//

reqDeleteModelProjection ::= ( ( reqDeleteRecordModelProjection
                               | reqDeleteListModelProjection
                               | reqDeleteMapModelProjection
                               ) reqDeleteModelPolymorphicTail?
                             )?

reqDeleteRecordModelProjection ::= '(' (reqDeleteFieldProjectionEntry ','?)* ')' { pin=1 }
reqDeleteFieldProjectionEntry ::= qid reqDeleteFieldProjection
reqDeleteFieldProjection ::= /* reqParamsAndAnnotations */ reqDeleteVarProjection

reqDeleteListModelProjection ::= '*' ( ( reqDeleteBracedVarProjection | reqDeleteVarProjection ) )? { pin=1 }

reqDeleteMapModelProjection ::= reqDeleteKeysProjection ( ( reqDeleteBracedVarProjection | reqDeleteVarProjection ) )?
reqDeleteKeysProjection ::= '['( '*' | ( ( reqDeleteKeyProjection ','? )* ) ) ']' {pin=1}
reqDeleteKeyProjection ::= datum reqParamsAndAnnotations

// ============= data language =============
// please keep in sync with data language from schema.bnf

dataValue ::= data | datum
private dataTypeSpec ::= typeRef

data ::= dataTypeSpec? '<' dataEntry* '>' {pin=2}
dataEntry ::= qid ':' datum ','? {pin=2 recoverWhile=dataValueRecover}

// add metadata support?
datum ::= recordDatum | mapDatum | listDatum | primitiveDatum | enumDatum | nullDatum

recordDatum ::= dataTypeSpec? '{' recordDatumEntry* '}' {pin=2 extends=datum}
recordDatumEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

mapDatum ::= dataTypeSpec? '(' mapDatumEntry* ')' {pin=2 extends=datum}
mapDatumEntry ::= datum ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

listDatum ::= dataTypeSpec? '[' (dataValue ','?)* ']' {pin=2 extends=datum}

primitiveDatum ::= (dataTypeSpec '@')? (string | number | boolean) {pin=2 extends=datum} // todo only differentiate string/non-string?

enumDatum ::= '#' qid {extends=datum pin=1}

nullDatum ::= (dataTypeSpec '@')? 'null' {pin=2 extends=datum}

private dataValueRecover ::= ! ( '#' | qid | primitiveDatum | '}' | ')' | '>' | ']' | ',' | '?' )
