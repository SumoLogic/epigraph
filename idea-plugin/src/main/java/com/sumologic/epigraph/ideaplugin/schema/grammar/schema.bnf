{
  parserClass="com.sumologic.epigraph.ideaplugin.schema.parser.SchemaParser"

  elementTypeHolderClass="com.sumologic.epigraph.ideaplugin.schema.lexer.SchemaElementTypes"
  elementTypePrefix="S_"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.lexer.SchemaElementType"
  tokenTypeClass="com.sumologic.epigraph.ideaplugin.schema.lexer.SchemaElementType"

  psiClassPrefix="Schema"
  psiImplClassSuffix="Impl"
  psiPackage="com.sumologic.epigraph.ideaplugin.schema.psi"
  psiImplPackage="com.sumologic.epigraph.ideaplugin.schema.psi.impl"
  psiImplUtilClass="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    MAP = 'map'
    DEFAULT = 'default'
    NODEFAULT = 'nodefault'
    LIST = 'list'
    RECORD = 'record'
    EXTENDS = 'extends'
    VARTYPE='vartype'
    ENUM='enum'
    META='meta'
    SUPPLEMENT='supplement'
    SUPPLEMENTS='supplements'
    WITH='with'
    POLYMORPHIC='polymorphic'
    ABSTRACT='abstract'
    OVERRIDE='override'

    INTEGER_T='integer'
    LONG_T='long'
    DOUBLE_T='double'
    BOOLEAN_T='boolean'
    STRING_T='string'

    BACKTICK = '`'
    COLON = ':'
    SEMI_COLON = ';'
    DOT = '.'
    COMMA = ','
    EQ = '='
    PLUS = '+' // change to '&' ?
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'
    STAR = '*'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'
    //string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    data_value='regexp:\|' // DUMMY, real implementation in SchemaLexer.flex

    id = 'regexp:\p{Alpha}\p{Alnum}*'
  ]

  pin(".*Body") = 1
  //pin(".*TypeDef") = 1
  //recoverWhile(".*Body") = "bodyRecover"
  recoverWhile(".*Part") = "partRecover"

  // extends(".*.TypeDef") = "typeDef" // types hierarchy doesn't work with stubs
  implements(".*TypeDef")="com.sumologic.epigraph.ideaplugin.schema.psi.SchemaTypeDef"

  implements(".*TypeBody") = "com.sumologic.epigraph.ideaplugin.schema.psi.CustomParamsHolder"
  extends(".*TypeBody") = "com.sumologic.epigraph.ideaplugin.schema.psi.impl.CustomParamHolderImpl"
}

// consider separating fields/types/decl parts by either ',' or newlines,
// otherwise stuff can get confusing, e.g.
// record { f1:t1 f2:t2 }

root ::= namespaceDecl imports defs

// either quoted or unquoted id
private qid ::= '`' id '`' | id

imports ::= importStatement*
importStatement ::= 'import' fqn starImportSuffix? {pin=1 recoverWhile="declRecover"}
starImportSuffix ::= '.' '*'

namespaceDecl ::= 'namespace' fqn namespaceBody? {
  methods=[getFqn2 toString]
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaNamespaceDeclStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaNamespaceDeclStubElementType"
  pin=1
  recoverWhile="declRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqnSegment ::= qid {
  implements="com.intellij.psi.PsiNameIdentifierOwner"
  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
fqn ::= fqnSegment ('.' fqnSegment)* { methods=[getFqn] }

private typeName ::= qid
typeRef ::= fqnTypeRef | anonList | anonMap {name="type"}
fqnTypeRef ::= fqn

defs ::= def*
private def ::= typeDefWrapper | supplementDef {recoverWhile="declRecover"}

typeDefWrapper ::= varTypeDef | recordTypeDef | mapTypeDef | listTypeDef | primitiveTypeDef | enumTypeDef {
  name="type definition"
  methods=[getElement delete toString]
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaTypeDefWrapperStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaTypeDefWrapperStubElementType"
}

anonList ::= 'list' '[' typeRef defaultOverride? ']' {pin=1}// TODO rename to `listType`? `concreteList`?
anonMap ::= 'map' '[' typeRef ',' typeRef defaultOverride? ']' {pin=1} // TODO rename to `mapType`?

extendsDecl ::= 'extends' typeRef (',' typeRef)*
defaultOverride ::= 'nodefault' | 'default' qid
customParam ::= qid '=' data_value ';' { // TODO embed data language instead
  name="custom attribute"
  implements="com.intellij.psi.PsiNamedElement"
  methods = [getName setName getNameIdentifier]
  pin = 2
}

metaDecl ::= 'meta' fqnTypeRef // we don't allow anonList or anonMap as meta

varTypeDef ::= 'vartype' typeName extendsDecl? varTypeSupplementsDecl? defaultOverride? varTypeBody? {
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaVarTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaVarTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaVarTypeDefStubElementType"
  pin=1
}
varTypeSupplementsDecl ::= 'supplements' fqnTypeRef (',' fqnTypeRef)*
varTypeBody ::= '{' varTypeBodyPart* '}'
private varTypeBodyPart ::= varTypeMemberDecl | customParam
varTypeMemberDecl ::= 'override'? qid ':' typeRef memberBody? {
  implements=["com.sumologic.epigraph.ideaplugin.schema.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier]
  pin=3
}
private memberBody ::= '{' memberBodyPart* '}'
private memberBodyPart ::= customParam

recordTypeDef ::= 'abstract'? 'polymorphic'? 'record' typeName extendsDecl? metaDecl? recordSupplementsDecl? recordTypeBody? {
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaRecordTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaRecordTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaRecordTypeDefStubElementType"
  pin=3
}
recordSupplementsDecl ::= 'supplements' combinedFqns (',' combinedFqns)*
recordTypeBody ::= '{' recordBodyPart* '}'
private recordBodyPart ::= fieldDecl | customParam
fieldDecl ::= 'override'? 'abstract'? qid ':' typeRef defaultOverride? fieldBody? {
  implements=["com.sumologic.epigraph.ideaplugin.schema.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier]
  pin=4
}
private fieldBody ::= '{' fieldBodyPart* '}'
private fieldBodyPart ::= customParam

//listTypeDef2 ::= 'list' typeName extendsDecl listTypeBody? // allows inheritance from lists w/o type params
listTypeDef ::= 'abstract'? 'polymorphic'? anonList typeName extendsDecl? metaDecl? listTypeBody? {
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaListTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaListTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaListTypeDefStubElementType"
  pin=3
}
listTypeBody ::= '{' listTypeBodyPart* '}'
private listTypeBodyPart ::= customParam

mapTypeDef ::= 'abstract'? 'polymorphic'? anonMap typeName extendsDecl? metaDecl? mapTypeBody? {
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaMapTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaMapTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaMapTypeDefStubElementType"
  pin=3
}
mapTypeBody ::= '{' mapTypeBodyPart* '}'
private mapTypeBodyPart ::= customParam

enumTypeDef ::= 'enum' typeName metaDecl? enumTypeBody { // extends?
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaEnumTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaEnumTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaEnumTypeDefStubElementType"
  pin=1
}
enumTypeBody ::= '{' enumTypeBodyPart* '}'
private enumTypeBodyPart ::= customParam | enumMemberDecl
enumMemberDecl ::= qid enumMemberBody? {
  implements=["com.sumologic.epigraph.ideaplugin.schema.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier]
  pin=1
}
private enumMemberBody ::='{' enumMemberBodyPart* '}'
private enumMemberBodyPart ::= customParam

primitiveTypeDef ::= 'abstract'? 'polymorphic'? primitiveKind typeName extendsDecl? metaDecl? primitiveTypeBody? {
  extends="com.sumologic.epigraph.ideaplugin.schema.psi.impl.SchemaPrimitiveTypeDefImplBase"
  stubClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaPrimitiveTypeDefStub"
  elementTypeClass="com.sumologic.epigraph.ideaplugin.schema.psi.stubs.SchemaPrimitiveTypeDefStubElementType"
  pin=3
}
primitiveKind ::= 'string' | 'integer' | 'long' | 'double' | 'boolean'
primitiveTypeBody ::= '{' primitiveBodyPart* '}'
private primitiveBodyPart ::= customParam // | ...

supplementDef ::= 'supplement' combinedFqns (',' combinedFqns)* 'with' fqnTypeRef {pin=1}

// todo? for multi:  // not too good, no name for artificial vartype hence no common interface
// supplement User,Company with {
//    mySuperAnnotation = "sdf"; ??
//    foo : MyType { sdf = "sdf" }
// }

/*
supplement FooRec, BarRec with record { // not good since supplemented records won't have common interface for new field(s)
    newField: SomeType
}
*/

combinedFqns ::= fqnTypeRef ('+' fqnTypeRef)*

private declRecover ::= ! ('import' | 'namespace' | 'polymorphic' | 'abstract' | 'record' |
                           'map' | 'list' | 'vartype' | 'enum' | 'supplement'| primitiveKind)
private partRecover ::= ! ('}' | qid | 'abstract' | 'override' )
