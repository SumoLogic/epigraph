buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath group: 'org.ow2.asm', name: 'asm', version: '5.0.3'
  }
}

plugins {
  id 'com.github.johnrengelman.shadow' version '1.2.3'
}

apply plugin: 'base'

// TODO single task for full rebuild:
// gradle updateFileList2 packageLightPsi relocate copyPrebuilt && mvn clean install

// `updateFileList` updates resources/light-psi-filelist.txt
// `packageLightPsi` rebuilds jar in build/tmp/light-psi-tmp.jar using the file list
// `relocate` adds licenses and relocates packages, puts it into resources/light-psi-prebuilt.jar (which is checked in into git)
//
// on every build `copyPrebuilt` copies resouces/light-psi-prebuilt.jar to build/distributions with appropriate name -- this is `default` configuration artefact

configurations {
  lightPsiTmp
  fileList
}

dependencies {
  lightPsiTmp files("$buildDir/tmp/light-psi-tmp.jar") // this is where packageLightPsi puts it
  fileList project(":epigraph-java-schema-parser")
}

ext.isFolder = { String path ->
  if (path == null) return false
  def file = new File(path)
  return file.exists() && file.isDirectory()
}

ext.isFile = { String path ->
  if (path == null) return false
  def file = new File(path)
  return file.exists() && file.isFile()
}

task locateIdeaHome {
  doLast {
    def locations = [
        System.getenv('IDEA_HOME'),
        System.getProperty('IDEA_HOME'),
        '/Applications/IntelliJ IDEA CE.app/Contents',
        '/Applications/IntelliJ IDEA.app/Contents',
        "${System.getProperty('user.home')}/idea",
        "${System.getProperty('user.home')}/Applications/IntelliJ IDEA CE.app/Contents",
        "${System.getProperty('user.home')}/Applications/IntelliJ IDEA.app/Contents"
    ]

    def ideaHome = locations.find { isFolder(it) }
    if (ideaHome == null) throw new GradleException('Can\'t detect IDEA location, please set IDEA_HOME')

    project.ext.ideaHome = ideaHome
  }
}

task locateGrammarKit {
  doLast {
    def ideaVersion = '2016.3' // todo get from some global config
    def locations = [
        System.getenv('GKIT_JAR'),
        System.getProperty('GKIT_JAR'),
        "${System.getProperty('user.home')}/Library/Application Support/IdeaIC$ideaVersion/GrammarKit/lib/grammar-kit.jar",
        "${System.getProperty('user.home')}/Library/Application Support/IntelliJIdea$ideaVersion/GrammarKit/lib/grammar-kit.jar",
        "${System.getProperty('user.home')}/.IdeaIC$ideaVersion/GrammarKit/lib/grammar-kit.jar",
        "${System.getProperty('user.home')}/.IntelliJIdea$ideaVersion/GrammarKit/lib/grammar-kit.jar"
    ]

    def grammarKit = locations.find { isFile(it) }
    if (grammarKit == null) throw new GradleException('Can\'t detect grammar-kit.jar location, please set GKIT_JAR')

    logger.info("grammar kit found at $grammarKit")
    project.ext.grammarKit = grammarKit
  }
}

task updateFileList2(dependsOn: [locateIdeaHome, locateGrammarKit]) {
  doLast {
    def schemaParserJar = project.configurations.fileList.find { it.name.contains('schema-parser') }
    if (schemaParserJar == null) throw new GradleException('Can\'t locate schema-parser jar, did you build it?')

    def producer = new FileListProducer(project.logger, project.ext.ideaHome, new File(project.ext.grammarKit), schemaParserJar)

    producer.traverseAllClasses(schemaParserJar)
    // extra classes (accessed via reflection?)
//  producer.traverse('com/intellij/openapi/vfs/encoding/EncodingManagerImpl')

    def fileListPath = "$projectDir/resources/light-psi-filelist.txt"
    producer.buildClassesList(fileListPath)
    new File(fileListPath).append('misc/registry.properties')
  }
}

// deprecated: use updatedFileList2
task updateFileList(dependsOn: [locateIdeaHome, locateGrammarKit]) {
  doLast {
    // steps:
    // Assemble schema-parser standalone runnable
    // Patch it's launcher script to use real IDEA installation and Grammar-Kit instead of our light-psi jar
    // Run it capturing the list of loaded classes to resources/light-psi-filelist.txt

    def fileList = "$projectDir/resources/light-psi-filelist.txt"
    def fileListFile = new File(fileList)
    fileListFile.parentFile.mkdirs()

    // TODO patch template must be updated to remove our new light-psi jar from classpath
    // prepare wrapper patch
    def patch = new File('resources/schema-parser.patch.src').text
    patch = patch.replaceAll('@IDEALIB', "$project.ext.ideaHome/lib")
    patch = patch.replaceAll('@GKITJAR', project.ext.grammarKit)

    def patchTarget = "$buildDir/schema-parser.patch"
    def patchTargetFile = new File(patchTarget)
    patchTargetFile.parentFile.mkdirs()
    patchTargetFile.write(patch)

    // TODO rewrite it in groovy? still has to invoke external JVM process
    exec {
      commandLine 'sh', 'resources/update-filelist.sh', fileListFile.canonicalPath
    }

    // add resource files
    fileListFile.append('misc/registry.properties\n')
  }
}

import java.util.jar.*

task packageLightPsi(dependsOn: [locateIdeaHome, locateGrammarKit]) {
  doLast {
    // repackage light-psi-tmp.jar using real IDEA/GrammarKit
    // classes and resources listed in resources/light-psi-filelist.txt

    def sources = [project.ext.grammarKit]
    sources.addAll(new File("${project.ext.ideaHome}/lib").listFiles(new FilenameFilter() {
      @Override
      boolean accept(File dir, String name) {
        name.endsWith('.jar')
      }
    }).collect { it.getCanonicalPath() })

    def fileListLocation = "$projectDir/resources/light-psi-filelist.txt"
    def fileSet = new File(fileListLocation).readLines() as Set

    // take as an argument ?
//  def targetLocation = 'resources/light-psi-prebuilt.jar'
    def targetLocation = "$buildDir/tmp/light-psi-tmp.jar"
    new File(targetLocation).parentFile.mkdirs()

    def manifest = new Manifest()
    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0')

    def target = new JarOutputStream(new FileOutputStream(targetLocation), manifest)

    def buffer = new byte[4096]

    sources.each { String sourceLocation ->
      logger.debug("Checking $sourceLocation")
      def sourceFile = new File(sourceLocation)
      def source = new JarInputStream(new FileInputStream(sourceLocation))

      for (JarEntry entry = source.getNextJarEntry(); entry != null; entry = source.getNextJarEntry()) {
        if (fileSet.contains(entry.name)) {
          logger.debug("Adding $sourceLocation!${entry.name}")
          target.putNextEntry(entry)

          int length
          while ((length = source.read(buffer)) != -1) {
            target.write(buffer, 0, length)
          }

          fileSet.remove(entry.name)
        }
      }
    }

    if (!fileSet.isEmpty()) {
      throw new GradleException("Missing files: $fileSet")
    }

    target.close()
  }
}

task relocate(type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
  destinationDir = file("$projectDir/resources")
  archiveName = 'light-psi-prebuilt.jar'

  configurations = [project.configurations.lightPsiTmp] // build/tmp/light-psi-tmp.jar
  from("$projectDir/resources") { include 'licenses/*' }

  relocate 'com.google', 'epigraph.com.google'
  relocate 'gnu', 'epigraph.gnu'
  relocate 'org.picocontainer', 'epigraph.org.picocontainer'
  relocate 'net.jcip', 'epigraph.net.jcip'
}

task copyPrebuilt(type: Copy) {
  from('resources') {
    include 'light-psi-prebuilt.jar'
    rename 'light-psi-prebuilt', "$archivesBaseName-$version"
  }
  into distsDir
}

artifacts {
  // should be 'archives'
  // http://stackoverflow.com/questions/39068090/gradle-archives-artifacts-not-populated-to-default-configuration
  'default'(file("$distsDir/$archivesBaseName-${version}.jar")) {
    name archivesBaseName
    type 'jar'
    builtBy copyPrebuilt
  }
}

publishing {
  publications {
    prebuilt(MavenPublication) {
      artifact file("$distsDir/$archivesBaseName-${version}.jar")
    }
  }
}

publishToMavenLocal.dependsOn copyPrebuilt
publish.dependsOn copyPrebuilt

import org.objectweb.asm.*
import org.objectweb.asm.signature.*
import java.util.*
import java.net.*
import java.util.zip.*

// switch to this instead of asm:
// http://stackoverflow.com/questions/1753337/determine-the-classes-referenced-in-a-class-file/1753747?noredirect=1#comment65681526_1753747
class FileListProducer {
  private MyClassVisitor visitor
  private Logger logger
  private ClassLoader classLoader

  FileListProducer(Logger logger, String ideaHome, Object[] additionalJars) {
    List<URL> jars = new ArrayList<>()

    jars.addAll(additionalJars.collect { it.toURL() })
    jars.addAll(new File(ideaHome, 'lib').listFiles(new FilenameFilter() {
      @Override
      boolean accept(File dir, String name) {
        return name.endsWith('.jar')
      }
    }).collect { it.toURL() })

    classLoader = new URLClassLoader(jars as URL[])
    def filter = classNameFilter()
    // allow epigraph classes at this stage
    visitor = new MyClassVisitor(classLoader, { String cname -> cname.contains('epigraph') || filter(cname) })
    this.logger = logger
  }

  private Closure<Boolean> classNameFilter() {
    def filterPrefixes = ['java', 'sun', 'jdk', 'apple', 'com/apple', 'com/btr',
                          'com/sun', 'io/netty', 'org/w3c', 'org/xml', 'org/apache',
                          'kotlin', 'com/siyeh', 'dk', 'net/miginfocom', 'net/sf',
                          'org/imgscalr', 'org/iq80', 'org/java', 'org/ayatna',
                          'org/jdesktop', 'org/jdom', 'org/objectweb',
                          'com/intellij/analysis',
                          'com/intellij/application',
                          'com/intellij/codeEditor',
                          'com/intellij/codeHighlighting',
//                          'com/intellij/codeInsight',
                          'com/intellij/codeInspection',
                          'com/intellij/diagnostic',
                          'com/intellij/diff',
                          'com/intellij/facet',
                          'com/intellij/featureStatistics',
                          'com/intellij/find',
                          'com/intellij/formatting',
                          'com/intellij/icons',
//                          'com/intellij/ide',
                          'com/intellij/injected',
                          'com/intellij/internal',
                          'com/intellij/notification',
                          'com/intellij/openapi/actionSystem',
                          'com/intellij/openapi/command',
//                          'com/intellij/openapi/editor',
//                          'com/intellij/openapi/fileEditor',
                          'com/intellij/openapi/ide',
                          'com/intellij/openapi/keymap',
                          'com/intellij/openapi/module',
                          'com/intellij/openapi/preview',
                          'com/intellij/openapi/roots',
                          'com/intellij/openapi/updateSettings',
                          'com/intellij/openapi/wm',
                          'com/intellij/patterns',
                          'com/intellij/ui/mac',
//                          'com/intellij/reference',
                          'com/intellij/usageView',
                          'com/intellij/xml',
                          'org/jetbrains/annotations',
                          'org/jetbrains/jps',
//                          'org/jetbrains/org',
                          'ws/epigraph']
    return { String cn -> filterPrefixes.find { cn.startsWith(it) } == null }
  }

  void traverse(String className) {
    visitor.visitClass(className)
  }

  void traverseAllClasses(File jarFile) {
    def zip = new ZipInputStream(new FileInputStream(jarFile))
    for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {
      if (!entry.isDirectory() && entry.getName().endsWith('.class')) {
        def className = entry.getName()
        className = className.substring(0, className.length() - '.class'.length());
        traverse(className)
      }
    }
  }

  void buildClassesList(String fileListPath) {
    def filter = classNameFilter()
    def classes = visitor.visited.findAll { filter(it) }.sort()

    def fileListFile = new File(fileListPath)
    fileListFile.parentFile.mkdirs()
    fileListFile.withWriter { out ->
      classes.each { out.println it + '.class' }
    }
  }
}

class MySignature extends SignatureVisitor {
  private MyClassVisitor classVisitor

  MySignature(MyClassVisitor classVisitor) {
    super(Opcodes.ASM5)
    this.classVisitor = classVisitor
  }

  @Override
  void visitClassType(String name) {
    classVisitor.visitClass(name)
  }
}

class MyClassVisitor extends ClassVisitor {
  private ClassLoader classLoader
  private Set<String> visited = new HashSet<>()
  private Closure<Boolean> classNameFilter
  private MySignature signatureVisitor = new MySignature(this)

  MyClassVisitor(ClassLoader classLoader, Closure<Boolean> classNameFilter) {
    super(Opcodes.ASM5)
    this.classLoader = classLoader
    this.classNameFilter = classNameFilter
  }

  Set<String> getVisited() {
    return visited
  }

  @Override
  void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
    visited.add(name)

    if (superName != null)
      visitClass(superName)

    if (interfaces != null)
      interfaces.each { visitClass it }
  }

  @Override
  FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
    if (signature != null) {
      visitSignature(signature)
    }
  }

  @Override
  MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
    visitSignature(signature)
    if (exceptions != null) for (String exception : exceptions) visitClass(exception)

    return new MethodVisitor(Opcodes.ASM5) {
      @Override
      void visitAttribute(Attribute attribute) {
        if (attribute.type != null)
          visitClass(attribute.type)
      }

      @Override
      void visitTypeInsn(int opcode, String type) {
        visitClass(type)
      }

      @Override
      void visitFieldInsn(int opcode, String owner, String name2, String desc2) {
        visitClass(owner)
      }

      @Override
      void visitMethodInsn(int opcode, String owner, String name2, String desc2, boolean itf) {
        visitClass(owner)
      }

      @Override
      void visitLdcInsn(Object cst) {
        if (cst instanceof Type) {
          Type t = (Type) cst;
          visitClass(t.descriptor)
        }
      }

      @Override
      void visitInvokeDynamicInsn(String name2, String desc2, Handle bsm, Object... bsmArgs) {
        bsmArgs.each {
          if (it instanceof Type) {
            Type t = (Type) it;
            visitClass(t.descriptor)
          }
        }
      }

      @Override
      void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
        if (type != null) visitClass(type)
      }

      @Override
      void visitLocalVariable(String name2, String desc2, String signature2, Label l1, Label l2, int index) {
        visitSignature(signature2)
      }
    }
  }

  @Override
  void visitOuterClass(String owner, String name, String desc) {
    visitClass(owner)
  }

  @Override
  AnnotationVisitor visitAnnotation(String desc, boolean visibleAtRuntime) {
    if (visibleAtRuntime) visitClass(desc)
  }

  @Override
  void visitInnerClass(String name, String outerName, String innerName, int access) {
    visitClass(name)
    if (outerName != null) visitClass(outerName)
  }

  void visitClass(String className) {
    try {
      if (className.startsWith('(')) return // TODO may be we need those

      def ocl = className
      if (className == null) return
      className = unwrapArray(className)
      if (className == null) return
      if (!visited.contains(className) && classNameFilter(className)) {
        InputStream inputStream = classLoader.getResourceAsStream(className + '.class')
        if (inputStream == null) {
          if (!className.startsWith('java') &&
              !className.startsWith('sun')) {
            if (ocl != className)
              System.err.println("Can't locate '$className' ($ocl)")
            else
              System.err.println("Can't locate '$className'")
          }
        } else new ClassReader(inputStream).accept(this, 0)
      }
    } catch (IOException e) {
      System.err.println("$e: $className")
    }
  }

  String unwrapArray(String className) {
    switch (className.charAt(0)) {
      case 'L': return className.substring(1, className.length() - 1)
      case '[':
        if (!className.startsWith('[')) return className
        switch (className.charAt(1)) {
          case 'L': return className.substring(2, className.length() - 1)
          case '[': return unwrapArray(className.substring(1))
          default: return null
        }
      default: return className
    }
  }

  private void visitSignature(String signature) {
    if (signature != null)
      new SignatureReader(signature).accept(signatureVisitor)
  }
}
