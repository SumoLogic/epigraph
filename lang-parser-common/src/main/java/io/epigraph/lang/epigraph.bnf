{
  parserClass="io.epigraph.lang.parser.EpigraphParser"

  elementTypeHolderClass="io.epigraph.lang.lexer.EpigraphElementTypes"
  elementTypePrefix="E_"
  elementTypeClass="io.epigraph.lang.lexer.EpigraphElementType"
  tokenTypeClass="io.epigraph.lang.lexer.EpigraphElementType"

  psiClassPrefix="Epigraph"
  psiImplClassSuffix="Impl"
  psiPackage="io.epigraph.lang.parser.psi"
  psiImplPackage="io.epigraph.lang.parser.psi.impl"
  psiImplUtilClass="io.epigraph.lang.parser.psi.impl.EpigraphPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    MAP = 'map'
    DEFAULT = 'default'
    NODEFAULT = 'nodefault'
    LIST = 'list'
    RECORD = 'record'
    EXTENDS = 'extends'
    VARTYPE='vartype'
    ENUM='enum'
    META='meta'
    SUPPLEMENT='supplement'
    SUPPLEMENTS='supplements'
    WITH='with'
    POLYMORPHIC='polymorphic'
    ABSTRACT='abstract'
    OVERRIDE='override'

    INTEGER_T='integer'
    LONG_T='long'
    DOUBLE_T='double'
    BOOLEAN_T='boolean'
    STRING_T='string'

    FORBIDDEN='forbidden'
    REQUIRED='required'
    PARAMETERS='parameters'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'

    id = 'regexp:(\p{Alpha}\p{Alnum}*)|(`([^`]*)`)'

    // for data lang
    NULL = 'null'
    SLASH = '/'
    PAREN_LEFT = '('
    PAREN_RIGHT = ')'
    ANGLE_LEFT = '<'
    ANGLE_RIGHT = '>'
    number="regexp:([0-9])+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    boolean="regexp:true|false"
  ]

  pin(".*Body") = 1
//  recoverWhile(".*Body") = "declBodyRecover"

  recoverWhile(".*Part") = "partRecover"

  // extends(".*.TypeDef") = "typeDef" // types hierarchy doesn't work with stubs
  implements(".*TypeDef")="io.epigraph.lang.parser.psi.EpigraphTypeDef"

  implements(".*TypeBody") = "io.epigraph.lang.parser.psi.CustomParamsHolder"
  extends(".*TypeBody") = "io.epigraph.lang.parser.psi.impl.CustomParamHolderImpl"
}

root ::= schemaRoot | idlRoot

// either quoted or unquoted id
qid ::= id {
  methods=[getName setName getCanonicalName]
}

// ============= Schema language ============

private schemaRoot ::= namespaceDecl imports defs


imports ::= importStatement*
importStatement ::= 'import' fqn {pin=1 recoverWhile="declRecover"}

namespaceDecl ::= 'namespace' fqn namespaceBody? {
  methods=[getFqn2 toString]
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphNamespaceDeclStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphNamespaceDeclStubElementType"
  pin=1
  recoverWhile="declRecover"
}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqnSegment ::= qid {
  implements="com.intellij.psi.PsiNameIdentifierOwner"
  methods=[getName setName getNameIdentifier getSchemaFqn getSchemaFqnTypeRef isLast getReference getFqn]
}
fqn ::= fqnSegment ('.' fqnSegment)* { methods=[getFqn] }

private typeName ::= qid
typeRef ::= fqnTypeRef | anonList | anonMap {name="type"}
fqnTypeRef ::= fqn { methods=[resolve] extends="typeRef" }
varTagRef ::= qid {
  implements="com.intellij.psi.PsiNameIdentifierOwner"
  methods=[setName getNameIdentifier getReference]
}

/// defs

defs ::= def*
private def ::= typeDefWrapper | supplementDef {recoverWhile="declRecover"}

// need a wrapper because inheritance doesn't play nicely with PSI stubs
typeDefWrapper ::= varTypeDef | recordTypeDef | mapTypeDef | listTypeDef | primitiveTypeDef | enumTypeDef {
  name="type definition"
  methods=[getElement delete toString]
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphTypeDefWrapperStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphTypeDefWrapperStubElementType"
}

private typeDefModifiers ::= 'abstract'?
private typeMemberModifiers ::= 'override'? 'abstract'?

valueTypeRef ::= 'polymorphic'? typeRef defaultOverride?

anonList ::= 'list' '[' valueTypeRef ']' {pin=1 extends="typeRef" }
anonMap ::= 'map' '[' typeRef ',' valueTypeRef ']' {pin=1 extends="typeRef" }

extendsDecl ::= 'extends' fqnTypeRef (',' fqnTypeRef)* {pin=1}
supplementsDecl ::= 'supplements' fqnTypeRef (',' fqnTypeRef)* {pin=1}

defaultOverride ::= 'nodefault' | 'default' varTagRef
customParam ::= qid '=' dataValue {
  name="custom attribute"
  implements="com.intellij.psi.PsiNamedElement"
  methods = [getName setName getNameIdentifier]
  pin = 2
}

metaDecl ::= 'meta' fqnTypeRef { pin=1 } // we don't allow anonList or anonMap as meta

/// vartype

varTypeDef ::= typeDefModifiers 'vartype' typeName extendsDecl? supplementsDecl? defaultOverride? varTypeBody? {
  methods=[supplemented]
  extends="io.epigraph.lang.parser.psi.impl.EpigraphVarTypeDefImplBase"
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphVarTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphVarTypeDefStubElementType"
  pin=2
}
varTypeBody ::= '{' (varTypeBodyPart ','?)* '}'
private varTypeBodyPart ::= varTagDecl | customParam
varTagDecl ::= typeMemberModifiers qid ':' typeRef varTypeMemberBody? {
  implements=["io.epigraph.lang.parser.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="io.epigraph.lang.parser.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier getTextOffset getPresentation getVarTypeDef]
  pin=3
}
private varTypeMemberBody ::= '{' (varTypeMemberBodyPart ','?)* '}'
private varTypeMemberBodyPart ::= customParam

/// record

recordTypeDef ::= typeDefModifiers 'record' typeName extendsDecl? metaDecl? supplementsDecl? recordTypeBody? {
  methods=[supplemented]
  extends="io.epigraph.lang.parser.psi.impl.EpigraphRecordTypeDefImplBase"
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphRecordTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphRecordTypeDefStubElementType"
  pin=2
}
recordTypeBody ::= '{' (recordBodyPart ','?)* '}'
private recordBodyPart ::= fieldDecl | customParam
fieldDecl ::= typeMemberModifiers qid ':' valueTypeRef fieldBody? {
  implements=["io.epigraph.lang.parser.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="io.epigraph.lang.parser.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier getTextOffset getPresentation getRecordTypeDef]
  pin=3
}
private fieldBody ::= '{' (fieldBodyPart ','?)* '}'
private fieldBodyPart ::= customParam

/// list

//listTypeDef2 ::= 'list' typeName extendsDecl listTypeBody? // allows inheritance from lists w/o type params
listTypeDef ::= typeDefModifiers anonList typeName extendsDecl? metaDecl? supplementsDecl? listTypeBody? {
  extends="io.epigraph.lang.parser.psi.impl.EpigraphListTypeDefImplBase"
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphListTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphListTypeDefStubElementType"
  pin=2
}
listTypeBody ::= '{' (listTypeBodyPart ','?)* '}'
private listTypeBodyPart ::= customParam

/// map

mapTypeDef ::= typeDefModifiers anonMap typeName extendsDecl? metaDecl? supplementsDecl? mapTypeBody? {
  extends="io.epigraph.lang.parser.psi.impl.EpigraphMapTypeDefImplBase"
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphMapTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphMapTypeDefStubElementType"
  pin=2
}
mapTypeBody ::= '{' (mapTypeBodyPart ','?)* '}'
private mapTypeBodyPart ::= customParam

/// enum

// abstract? polymorphic?
enumTypeDef ::= 'enum' typeName metaDecl? enumTypeBody { // extends?
  extends="io.epigraph.lang.parser.psi.impl.EpigraphEnumTypeDefImplBase"
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphEnumTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphEnumTypeDefStubElementType"
  pin=1
}
enumTypeBody ::= '{' (enumTypeBodyPart ','?)* '}'
private enumTypeBodyPart ::= customParam | enumMemberDecl
enumMemberDecl ::= qid enumMemberBody? {
  implements=["io.epigraph.lang.parser.psi.CustomParamsHolder" "com.intellij.psi.PsiNamedElement"]
  extends="io.epigraph.lang.parser.psi.impl.CustomParamHolderImpl"
  methods=[getName setName getNameIdentifier]
  pin=1
}
private enumMemberBody ::='{' (enumMemberBodyPart ','?)* '}'
private enumMemberBodyPart ::= customParam

/// primitive

primitiveTypeDef ::= typeDefModifiers primitiveKind typeName extendsDecl? metaDecl? supplementsDecl? primitiveTypeBody? {
  extends="io.epigraph.lang.parser.psi.impl.EpigraphPrimitiveTypeDefImplBase"
  methods=[getPrimitiveTypeKind]
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphPrimitiveTypeDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphPrimitiveTypeDefStubElementType"
  pin=2
}
private primitiveKind ::= 'string' | 'integer' | 'long' | 'double' | 'boolean'
primitiveTypeBody ::= '{' (primitiveBodyPart ','?)* '}'
private primitiveBodyPart ::= customParam

supplementDef ::= 'supplement' fqnTypeRef (',' fqnTypeRef)* 'with' fqnTypeRef {
  methods=[sourceRef supplementedRefs source supplemented getPresentation toString]
  stubClass="io.epigraph.lang.parser.psi.stubs.EpigraphSupplementDefStub"
  elementTypeClass="io.epigraph.lang.parser.psi.stubs.EpigraphSupplementDefStubElementType"
  pin=1
}

private declRecover ::= ! ('import' | 'namespace' | 'polymorphic' | 'abstract' | 'record' | ',' |
                           'map' | 'list' | 'vartype' | 'enum' | 'supplement'|
                           'string' | 'integer' | 'long' | 'double' | 'boolean')

// ------------- data language -------------

//dataValue ::= dataTypeSpec? (dataVar | dataVarValue)
//private dataVarValue ::= dataRecord | dataMap | dataList | dataEnum | dataPrimitiveValue | 'null'
//private dataTypeSpec ::= ( fqnTypeRef '/' )*
dataValue ::= dataTypeSpec? (dataVar | varValue)
private dataVarValue ::= dataTypeSpec? varValue   // because we want (foo/bar:baz) ?
private varValue ::= dataRecord | dataMap | dataList | dataEnum | dataPrimitive | 'null'
private dataTypeSpec ::= ( fqnTypeRef '/' )* // TODO we only need single type spec now

dataVar ::= '<' dataVarEntry* '>' {pin=1 extends=dataValue}
dataVarEntry ::= qid ':' dataVarValue ','? {pin=2 recoverWhile=dataValueRecover}

dataRecord ::= '{' dataRecordEntry* '}' {pin=1 extends=dataValue}
dataRecordEntry ::= qid ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

dataMap ::= '(' dataMapEntry* ')' {pin=1 extends=dataValue}
dataMapEntry ::= dataVarValue ':' dataValue ','? {pin=2 recoverWhile=dataValueRecover}

dataList ::= '[' (dataValue ','?)* ']' {pin=1 extends=dataValue}

dataEnum ::= qid {extends=dataValue}

dataPrimitive ::= string | number | boolean

private dataValueRecover ::= ! ( qid | dataPrimitive | '}' | ')' | '>' | ']' | 'abstract' | 'override' | ',' )

// ============= IDL language ============
// (work in progress )

private idlRoot ::=  opOutputVarProjection ( '%' opOutputVarProjection)*

// ------------- op projections -------------

// --- output

opParamProjection ::= qid ':' opInputModelProjection
opParameters ::= 'parameters' ':' '{' (opParamProjection ','?)* '}'

opOutputVarProjection ::= ('{' opOutputTagProjection* '}') | qid? ':' opOutputModelProjection
opOutputTagProjection ::= qid ':' opOutputModelProjection // custom params?

opOutputModelProjection ::= (opOutputRecordModelProjection | opOutputListModelProjection |
                             opOutputMapModelProjection | opOutputEnumModelProjection |
                             opOutputPrimitiveModelProjection ) opOutputModelProjectionBody?

opOutputModelProjectionBody ::= '{' (opOutputModelProjectionBodyPart ','?)* '}' {pin=1}
opOutputModelProjectionBodyPart ::= 'required' | opParameters | customParam

// op output record
opOutputRecordModelProjection ::= '(' (opOutputFieldProjection ','?)* ')' opOutputRecordPolyBranch? {pin=1}
opOutputFieldProjection ::= qid opOutputFieldProjectionBody? (':' opOutputVarProjection)?
opOutputFieldProjectionBody ::= '{' (opOutputFieldProjectionBodyPart ','?)* '}'
opOutputFieldProjectionBodyPart ::= opParameters | customParam
opOutputRecordPolyBranch ::= '~' ( opOutputRecordSinglePolyBranch | opOutputRecordMultiPolyBranch) {pin=1}
opOutputRecordSinglePolyBranch ::= fqnTypeRef opOutputRecordModelProjection
opOutputRecordMultiPolyBranch ::= '(' (opOutputRecordSinglePolyBranch (',' opOutputRecordSinglePolyBranch)*)? ')' {pin=1}

// files : Files default FileList *(..) ~FileList2(..)
// op output list
opOutputListModelProjection ::= '*' '(' opOutputVarProjection ')' opOutputListPolyBranch? {pin=1}
opOutputListPolyBranch ::= '~' ( opOutputListSinglePolyBranch | opOutputListMultiPolyBranch) {pin=1}
opOutputListSinglePolyBranch ::= fqnTypeRef opOutputListModelProjection
opOutputListMultiPolyBranch ::= '(' (opOutputListSinglePolyBranch (',' opOutputListSinglePolyBranch)*)? ')' {pin=1}

opOutputMapModelProjection ::= opOutputKeyProjection '(' opOutputVarProjection ')' opOutputMapPolyBranch? {pin=1}
//opOutputKeyProjection ::= '[' (opOutputKeyProjectionPart ','?)* ']' {pin=1}
opOutputKeyProjection ::= '[' opOutputKeyProjectionPart ']' {pin=1}
opOutputKeyProjectionPart ::= 'record'
// opOutputKeyProjectionPart ::= 'forbidden' | 'required' | opParameters | customParam
opOutputMapPolyBranch ::= '~' ( opOutputMapSinglePolyBranch | opOutputMapMultiPolyBranch) {pin=1}
opOutputMapSinglePolyBranch ::= fqnTypeRef opOutputMapModelProjection
opOutputMapMultiPolyBranch ::= '(' (opOutputMapSinglePolyBranch (',' opOutputMapSinglePolyBranch)*)? ')' {pin=1}

// can't distinguish between these
private opOutputEnumModelProjection ::= opSimpleModelProjection {pin=1}
private opOutputPrimitiveModelProjection ::= opSimpleModelProjection {pin=1}
opSimpleModelProjection ::= '#' {pin=1}

// -- input

opInputModelProjection ::= 'ip'
//opOutputModelProjection ::= (opOutputRecordModelProjection | opOutputListModelProjection |
//                             opOutputMapModelProjection | opOutputEnumModelProjection |
//                             opOutputPrimitiveModelProjection ) opOutputModelProjectionBody
//
//opOutputModelProjectionBody ::= '{' (opOutputModelProjectionBodyPart ','?)* '}'
//opOutputModelProjectionBodyPart ::= 'required' | opParameters | customParam

private partRecover ::= ! ('}' | qid | 'abstract' | 'override' | ',' | ']' )
