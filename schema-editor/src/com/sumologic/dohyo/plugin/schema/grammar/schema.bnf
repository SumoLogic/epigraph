{
  parserClass="com.sumologic.dohyo.plugin.schema.parser.SchemaParser"
//  parserUtilClass="com.sumologic.dohyo.plugin.schema.parser.SchemaParserUtil"

  elementTypeHolderClass="com.sumologic.dohyo.plugin.schema.lexer.SchemaElementTypes"
  elementTypePrefix="S_"
  elementTypeClass="com.sumologic.dohyo.plugin.schema.lexer.SchemaElementType"
  tokenTypeClass="com.sumologic.dohyo.plugin.schema.lexer.SchemaElementType"

  psiClassPrefix="Schema"
  psiImplClassSuffix="Impl"
  psiPackage="com.sumologic.dohyo.plugin.schema.psi"
  psiImplPackage="com.sumologic.dohyo.plugin.schema.psi.impl"
//  psiImplUtilClass="com.sumologic.dohyo.plugin.schema.psi.impl.SchemaPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    MAP = 'map'
    DEFAULT = 'default'
    LIST = 'list'
    RECORD = 'record'
    EXTENDS = 'extends'
    UNION = 'union'
    MULTI='multi' // TODO rename to 'poly'?
    ENUM='enum'

    INTEGER_T='integer'
    LONG_T='long'
    DOUBLE_T='double'
    BOOLEAN_T='boolean'
    STRING_T='string'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    EQ = '='
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    // id = 'regexp:_?(\p{Lower})\p{Alnum}*'
    id = 'regexp:_?\p{Alpha}\p{Alnum}*'
  ]

  pin(".*Body") = 1
  //recoverWhile(".*Body") = "bodyRecover"
  recoverWhile(".*Part") = "partRecover"

  extends(".*.TypeDef") = "typeDef"
}

// consider separating fields/types/decl parts by either ',' or newlines,
// otherwise stuff can get confusing, e.g.
// record { fields { f1:t1 f2:t2 } }

root ::= namespacedTypedefs*

namespacedTypedefs ::= namespaceDecl typeDefs

namespaceDecl ::= 'namespace' fqn namespaceBody? {pin=1 recoverWhile="namespaceRecover"}
private namespaceRecover ::= ! (id | 'namespace' | 'record' | 'union' | 'map' | 'list' | 'multi' |
                               'enum' | primitiveKind)

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqn ::= id ('.' id)*
private typeName ::= id
typeRef ::= fqn | anonList | anonMap {name="type"}
private typeDefs ::= typeDef*

typeDef ::= multiTypeDef | recordTypeDef | unionTypeDef | mapTypeDef | listTypeDef |
            primitiveTypeDef | enumTypeDef {name="type definition"}

anonList ::= 'list' '[' typeRef defaultOverride? ']' // TODO rename to `listType`? `concreteList`?
anonMap ::= 'map' '[' typeRef ',' typeRef defaultOverride? ']' // TODO rename to `mapType`?

extendsDecl ::= 'extends' typeRef (',' typeRef)*
defaultOverride ::= 'default' id
customParam ::= id '=' string  {pin = 1}// TODO real data parsing

multiTypeDef ::= 'multi' typeName extendsDecl? multiTypeBody?
multiTypeBody ::= '{' multiBodyPart* '}'
private multiBodyPart ::= memberDecl | customParam
memberDecl ::= 'default'? id ':' typeRef memberBody? {pin = 3}
private memberBody ::= '{' memberBodyPart* '}'
private memberBodyPart ::= customParam

recordTypeDef ::= 'record' typeName extendsDecl? recordTypeBody?
recordTypeBody ::= '{' recordBodyPart* '}'
private recordBodyPart ::= fieldDecl | customParam
fieldDecl ::= id ':' typeRef defaultOverride? fieldBody? {pin=2}
private fieldBody ::= '{' fieldBodyPart* '}'
private fieldBodyPart ::= customParam

unionTypeDef ::= 'union' typeName extendsDecl? unionTypeBody? // TODO require body? TODO remove extends? "contravariant" extension? same for enums
unionTypeBody ::= '{' unionBodyPart* '}'
private unionBodyPart ::= tagDecl | customParam
tagDecl ::= id ':' typeRef defaultOverride? tagBody? {pin=2}
private tagBody ::= '{' tagBodyPart* '}'
private tagBodyPart ::= customParam

//listTypeDef2 ::= 'list' typeName extendsDecl listTypeBody? // allows inheritance from lists w/o type params
listTypeDef ::= anonList typeName extendsDecl? listTypeBody?
listTypeBody ::= '{' listTypeBodyPart* '}'
private listTypeBodyPart ::= customParam

mapTypeDef ::= anonMap typeName extendsDecl? mapTypeBody?
mapTypeBody ::= '{' mapTypeBodyPart* '}'
private mapTypeBodyPart ::= customParam

primitiveTypeDef ::= primitiveKind typeName extendsDecl? primitiveTypeBody?
primitiveKind ::= 'string' | 'integer' | 'long' | 'double' | 'boolean'
primitiveTypeBody ::= '{' primitiveBodyPart* '}'
private primitiveBodyPart ::= customParam // | ...

enumTypeDef ::= 'enum' typeName enumTypeBody
enumTypeBody ::= '{' enumTypeBodyPart* '}'
private enumTypeBodyPart ::= customParam | enumMember
enumMember ::= id enumMemberBody? {pin=1}
enumMemberBody ::='{' enumMemberBodyPart* '}'
private enumMemberBodyPart ::= customParam

private partRecover ::= ! ('}' | id | 'default')
