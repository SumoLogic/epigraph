{
  parserClass="com.sumologic.epigraph.ideaPlugin.schema.parser.SchemaParser"
//  parserUtilClass="com.sumologic.dohyo.plugin.schema.parser.SchemaParserUtil"

  elementTypeHolderClass="com.sumologic.epigraph.ideaPlugin.schema.lexer.SchemaElementTypes"
  elementTypePrefix="S_"
  elementTypeClass="com.sumologic.epigraph.ideaPlugin.schema.lexer.SchemaElementType"
  tokenTypeClass="com.sumologic.epigraph.ideaPlugin.schema.lexer.SchemaElementType"

  psiClassPrefix="Schema"
  psiImplClassSuffix="Impl"
  psiPackage="com.sumologic.epigraph.ideaPlugin.schema.psi"
  psiImplPackage="com.sumologic.epigraph.ideaPlugin.schema.psi.impl"
  psiImplUtilClass="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.SchemaPsiImplUtil"

  generateTokenAccessors=true

  tokens=[
    NAMESPACE = 'namespace'
    IMPORT = 'import'
    MAP = 'map'
    DEFAULT = 'default'
    LIST = 'list'
    RECORD = 'record'
    EXTENDS = 'extends'
    UNION = 'union'
    MULTI='multi' // TODO rename to 'poly'?
    ENUM='enum'
    META='meta'
    SUPPLEMENT='supplement'
    SUPPLEMENTS='supplements'
    WITH='with'

    INTEGER_T='integer'
    LONG_T='long'
    DOUBLE_T='double'
    BOOLEAN_T='boolean'
    STRING_T='string'

    COLON = ':'
    DOT = '.'
    COMMA = ','
    EQ = '='
    PLUS = '+' // change to '&' ?
    CURLY_LEFT = '{'
    CURLY_RIGHT = '}'
    BRACKET_LEFT = '['
    BRACKET_RIGHT = ']'

    space='regexp:\s+'
    comment='regexp://.*'
    block_comment='regexp:/\*((?<!\*/)(.|\n))*'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    // id = 'regexp:_?(\p{Lower})\p{Alnum}*'
    id = 'regexp:\p{Alpha}\p{Alnum}*'
  ]

  pin(".*Body") = 1
  pin(".*TypeDef") = 1
  //recoverWhile(".*Body") = "bodyRecover"
  recoverWhile(".*Part") = "partRecover"

  extends(".*.TypeDef") = "typeDef"

  implements(".*TypeBody") = "com.sumologic.epigraph.ideaPlugin.schema.psi.CustomParamsHolder"
  extends(".*TypeBody") = "com.sumologic.epigraph.ideaPlugin.schema.psi.impl.CustomParamHolderImpl"
}

// consider separating fields/types/decl parts by either ',' or newlines,
// otherwise stuff can get confusing, e.g.
// record { f1:t1 f2:t2 }

root ::= namespaceDecl imports defs

imports ::= importStatement*
importStatement ::= 'import' fqn {pin=1 recoverWhile="declRecover"}

namespaceDecl ::= 'namespace' fqn namespaceBody? {pin=1 recoverWhile="declRecover"}

private namespaceBody ::= '{' namespaceBodyPart* '}'
private namespaceBodyPart ::= customParam // | ...

fqnSegment ::= id {
  implements="com.intellij.psi.PsiNameIdentifierOwner"
  methods=[getName setName getNameIdentifier getFqnTypeRef isLast getReference]
}
fqn ::= fqnSegment ('.' fqnSegment)* { methods=[getFqnString getLastSegment] }

private typeName ::= id
typeRef ::= fqnTypeRef | anonList | anonMap {name="type"}
fqnTypeRef ::= fqn

defs ::= def*
private def ::= typeDef | supplementDef {recoverWhile="declRecover"}

typeDef ::= multiTypeDef | recordTypeDef | unionTypeDef | mapTypeDef | listTypeDef |
            primitiveTypeDef | enumTypeDef {
              name="type definition"
              implements="com.sumologic.epigraph.ideaPlugin.schema.psi.TypeDefSchemaElement"
              extends="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.TypeDefSchemaElementImpl"
              methods = [getName setName getNameIdentifier getTextOffset]
            }

anonList ::= 'list' '[' fqnTypeRef defaultOverride? ']' {pin=1}// TODO rename to `listType`? `concreteList`?
anonMap ::= 'map' '[' fqnTypeRef ',' fqnTypeRef defaultOverride? ']' {pin=1} // TODO rename to `mapType`?

extendsDecl ::= 'extends' typeRef (',' typeRef)*
defaultOverride ::= 'default' id
customParam ::= id '=' string  {pin = 2}// TODO real data parsing

metaDecl ::= 'meta' fqnTypeRef // we don't allow anonList or anonMap as meta

multiTypeDef ::= 'multi' typeName extendsDecl? multiSupplementsDecl? multiTypeBody?
multiSupplementsDecl ::= 'supplements' fqnTypeRef (',' fqnTypeRef)*
multiTypeBody ::= '{' multiBodyPart* '}'
private multiBodyPart ::= multiMemberDecl | customParam
multiMemberDecl ::= 'default'? id ':' typeRef memberBody? {
  implements="com.sumologic.epigraph.ideaPlugin.schema.psi.CustomParamsHolder"
  extends="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.CustomParamHolderImpl"
  pin = 3
}
private memberBody ::= '{' memberBodyPart* '}'
private memberBodyPart ::= customParam

recordTypeDef ::= 'record' typeName extendsDecl? metaDecl? recordSupplementsDecl? recordTypeBody?
recordSupplementsDecl ::= 'supplements' combinedFqns (',' combinedFqns)*
recordTypeBody ::= '{' recordBodyPart* '}'
private recordBodyPart ::= fieldDecl | customParam
fieldDecl ::= id ':' typeRef defaultOverride? fieldBody? {
  implements="com.sumologic.epigraph.ideaPlugin.schema.psi.CustomParamsHolder"
  extends="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.CustomParamHolderImpl"
  pin=2
}
private fieldBody ::= '{' fieldBodyPart* '}'
private fieldBodyPart ::= customParam

unionTypeDef ::= 'union' typeName metaDecl? unionTypeBody
unionTypeBody ::= '{' unionBodyPart* '}'
private unionBodyPart ::= tagDecl | customParam
tagDecl ::= id ':' typeRef defaultOverride? tagBody? {
  implements="com.sumologic.epigraph.ideaPlugin.schema.psi.CustomParamsHolder"
  extends="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.CustomParamHolderImpl"
  pin=2
}
private tagBody ::= '{' tagBodyPart* '}'
private tagBodyPart ::= customParam

//listTypeDef2 ::= 'list' typeName extendsDecl listTypeBody? // allows inheritance from lists w/o type params
listTypeDef ::= anonList typeName extendsDecl? metaDecl? listTypeBody?
listTypeBody ::= '{' listTypeBodyPart* '}'
private listTypeBodyPart ::= customParam

mapTypeDef ::= anonMap typeName extendsDecl? metaDecl? mapTypeBody?
mapTypeBody ::= '{' mapTypeBodyPart* '}'
private mapTypeBodyPart ::= customParam

primitiveTypeDef ::= primitiveKind typeName extendsDecl? metaDecl? primitiveTypeBody?
primitiveKind ::= 'string' | 'integer' | 'long' | 'double' | 'boolean'
primitiveTypeBody ::= '{' primitiveBodyPart* '}'
private primitiveBodyPart ::= customParam // | ...

enumTypeDef ::= 'enum' typeName metaDecl? enumTypeBody // extends?
enumTypeBody ::= '{' enumTypeBodyPart* '}'
private enumTypeBodyPart ::= customParam | enumMemberDecl
enumMemberDecl ::= id enumMemberBody? {
  implements="com.sumologic.epigraph.ideaPlugin.schema.psi.CustomParamsHolder"
  extends="com.sumologic.epigraph.ideaPlugin.schema.psi.impl.CustomParamHolderImpl"
  pin=1
}
private enumMemberBody ::='{' enumMemberBodyPart* '}'
private enumMemberBodyPart ::= customParam

supplementDef ::= 'supplement' combinedFqns (',' combinedFqns)* 'with' fqnTypeRef {pin=1}

combinedFqns ::= fqnTypeRef ('+' fqnTypeRef)*

private declRecover ::= ! ('import' | 'namespace' | 'record' | 'union' | 'map' | 'list' | 'multi' | 'enum' | 'supplement'| primitiveKind)
private partRecover ::= ! ('}' | id | 'default')
