namespace epigraph.operations

import epigraph.projections.Annotation
import epigraph.projections.op.OpInputVarProjection
import epigraph.projections.op.OpOutputVarProjection
import epigraph.projections.op.OpParam
import epigraph.projections.op.OpVarPath
import epigraph.schema.Documented
import epigraph.schema.TypeRef
import epigraph.schema.VarTypeRef

// TODO this version is ahead of reality (Java classes)

record Resource extends Documented {
  fieldName: String
  fieldType: VarTypeRef
  operations: list[Operation]
}

abstract record Operation extends Documented {
  name: String { doc = "`null` means default operation" }
  params: list[OpParam]
  annotations: list[Annotation]

  path: OpVarPath // starts with resource field type

  inputType: TypeRef
  inputProjection: OpInputVarProjection // starts from `inputType` (can be different from resource field type)

  outputType: TypeRef // type `outputProjection` starts with
  outputProjection: OpOutputVarProjection // todo OpOutputFieldProjection = params + annotations + varProjection
}

// routing:
// if operation name is provided using query parameter: find operation by verb and name. Else:
// find all unnamed operations by verb (NB: methods can be overriden in X-HTTP-METHOD header)
// sort them by op path length in descending order then declaration order (must be stable!)
// for each of them:
// if it's a READ:
//   Try to parse read request projection against URL + `path` (the result of this would be `reqPath` + `reqOutputProjection`)
//   first that matches is our operation
// else (not a READ):
//   extract path from request (have to have full URL Request parser for this! )
//   try to match parsed path with operation path. First operation that matches is our operation

record CreateOperation extends Operation {
  // HTTP POST /people ~ *(status) <<< [ { user1 }, { user2 } ]
}

record ReadOperation extends Operation {
  // contract: outputType = path tip type, or resource fieldType if path is null
  // inputType = inputProjection = null
}

record UpdateOperation extends Operation {
  // HTTP PUT /people*(firstName, lastName) << { 123: { firstName: "Vasya" } } // updates firstName, removes lastName
  // HTTP PUT /people << { 123: { firstName: "Vasya" } }
  // HTTP PUT /people/123 << { firstName: "Vasya" }
  // HTTP PUT /people/123/firstName << "Vasya"

  //updateDataProjection: OpInputVarProjection // projection for body data, starts from `path` tip

  // contract: outputType = path tip type, or resource fieldType if path is null
}

record DeleteOperation extends Operation {
  // HTTP DELETE /people/123(firstName, lastName) <-- not supported for now
  // HTTP DELETE /people
  // HTTP DELETE /people/123
  // HTTP DELETE /people/123/firstName

  //deleteProjection: OpDeleteVarProjection // delete operation is guided by `path`

  // inputType = inputProjection = null
}

record CustomOperation extends Operation {
  // HTTP POST       /people/123 ~ /foo/234(bar, baz) ? param=value <<< { 'x' : 'y' }
  //  any ^ verb?     ^             ^                         ^          ^
  // path, guided by `path`         |                         |          |
  // ReqOutputVarProjection, parsed using `outputProjection`  |          |
  //                                            query parameters         |
  //                    request body, (de)serialized using `inputProjection`

  //path: OpVarPath
  //inputProjection: OpInputModelProjection
  //outputProjection: OpOutputVarProjection
}