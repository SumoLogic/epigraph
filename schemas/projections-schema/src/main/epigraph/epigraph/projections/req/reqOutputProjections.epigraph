namespace epigraph.projections.req

/**
 * Request-time projections specifying desired output structure of invoked operation response.
 */

// field(default tag projection)
// field:someTag(someTag projection)
// field:(tag1(tag1 projection), tag2(tag2 projection))

// /folders/123/items:list:(id, record:(id, name):(com.box.FolderRecord(...), com.box.FileRecord(...):(c.b.ImageFileRecord(size, ...))))

// /folders/123/items:list:(id, record:(id, name, :com.box.FolderRecord(...), :com.box.FileRecord(...)))
// /folders/123/items:list:(id, record:(id, name, :(com.box.FolderRecord(...), com.box.FileRecord(...))))
// /folders/123/items:list:(id, record:(id, name, com.box.FolderRecord:(...), com.box.FileRecord:(...)))
// /folders/123/items:map/123:(id, record)
// /folders/123/items:map[123,234]:(id, record)
// /folders/123/items(id, name, ...)
// /folders/123/items::record(id, name, ...)

import epigraph.projections.Annotation
import epigraph.schema.DatumType
import epigraph.schema.EnumType
import epigraph.schema.Field
import epigraph.schema.ListType
import epigraph.schema.MapType
import epigraph.schema.PrimitiveType
import epigraph.schema.RecordType
import epigraph.schema.Tag
import epigraph.schema.Type
import epigraph.data.Datum

// req projections also have a notion of path = number of steps without branching, e.g.
// /foo/bar(baz1, baz2) vs /foo(bar(baz1, baz2), qux)   or
// /a/b/c vs a(b(c))
// this is not reflected in the schema, but psi parsers return projections along with 'number of path steps' = path length

record ReqOutputVarProjection {
  type: Type
  tagProjections: map[String, ReqOutputTagProjectionEntry]
  polymorphicTail: list[ReqOutputVarProjection]
}

record ReqOutputTagProjectionEntry {
  tag: Tag
  projection: ReqOutputModelProjection
}

abstract record ReqOutputModelProjection {
  model: DatumType
  `required`: Boolean
  params: map[String, ReqParam]
  annotations: map[String, Annotation]
  `meta`: ReqOutputModelProjection
}

record ReqOutputRecordModelProjection extends ReqOutputModelProjection {
  override model: RecordType
  fieldProjections: list[ReqOutputFieldProjectionEntry]
}
record ReqOutputFieldProjectionEntry {
  field: Field
  projection: ReqOutputFieldProjection
}

record ReqOutputFieldProjection {
  `required`: Boolean  // artificial, required on field = required on all models
  // params: map[String, ReqParam]
  // annotations: map[String, Annotation]
  varProjection: ReqOutputVarProjection
}

record ReqOutputListModelProjection extends ReqOutputModelProjection {
  override model: ListType
  varProjection: ReqOutputVarProjection
}

record ReqOutputMapModelProjection extends ReqOutputModelProjection {
  override model: MapType
  keysRequired: Boolean // one for all keys
  keysProjection: ReqOutputKeysProjection { doc = "if `null` - all keys" }
  varProjection: ReqOutputVarProjection
}

record ReqOutputKeysProjection {
  keys: list[ReqOutputKeyProjection]
}

record ReqOutputKeyProjection {
  value: Datum { doc = "of appropriate (enclosing map key) type"}
  params: map[String, ReqParam]
  annotations: map[String, Annotation]
}

record ReqOutputEnumModelProjection extends ReqOutputModelProjection {
  override model: EnumType
}

record ReqOutputPrimitiveModelProjection extends ReqOutputModelProjection {
  override model: PrimitiveType
}
