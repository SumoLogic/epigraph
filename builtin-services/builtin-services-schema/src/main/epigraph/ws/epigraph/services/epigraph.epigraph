namespace ws.epigraph.services

import epigraph.annotations.Doc
import epigraph.data.BooleanDatum
import epigraph.data.Data
import epigraph.data.Datum
import epigraph.data.DoubleDatum
import epigraph.data.EntityData
import epigraph.data.IntegerDatum
import epigraph.data.ListDatum
import epigraph.data.LongDatum
import epigraph.data.MapDatum
import epigraph.data.PrimitiveDatum
import epigraph.data.RecordDatum
import epigraph.data.StringDatum
import epigraph.data.Value
import epigraph.schema.Annotations
import epigraph.schema.AnonListTypeName
import epigraph.schema.AnonMapTypeName
import epigraph.schema.DataType
import epigraph.schema.DataTypeName
import epigraph.schema.DatumType
import epigraph.schema.Field
import epigraph.schema.ListType
import epigraph.schema.MapType
import epigraph.schema.NameString
import epigraph.schema.PrimitiveType
import epigraph.schema.QualifiedTypeName
import epigraph.schema.RecordType
import epigraph.schema.Tag
import epigraph.schema.Type
import epigraph.schema.TypeName
import epigraph.schema.VarType

record EpigraphResource {
  @Doc "Epigraph built-in services resource root type"

  types: map[NameString, Type]
}

resource epigraph: EpigraphResource {

  // data

  outputProjection valueProjection: Value = (
    data $datumProjection,
    error (statusCode, message, exception)
  )

  outputProjection dataProjection: Data = ( type $typeProjection ) ~ (
    EntityData $entityDataProjection,
    Datum $datumProjection
  )

  outputProjection entityDataProjection: EntityData = (
    tags [] ($dataProjection)
  )

  outputProjection datumProjection: Datum = ( type $datumTypeProjection )  ~ (
    RecordDatum $recordDatumProjection,
    MapDatum $mapDatumProjection,
    ListDatum $listDatumProjection,
    PrimitiveDatum $primitiveDatumProjection
  )

  outputProjection recordDatumProjection: RecordDatum = ( fields [] ( $valueProjection ) )

  outputProjection mapDatumProjection: MapDatum = ( entries [] ( $valueProjection ) )

  outputProjection listDatumProjection: ListDatum = ( entries * ( $valueProjection ) )

  outputProjection primitiveDatumProjection: PrimitiveDatum = () ~ (
    StringDatum (value),
    IntegerDatum (value),
    LongDatum (value),
    DoubleDatum (value),
    BooleanDatum (value)
  )

  // todo enum

  // annotations

  outputProjection annotationsProjection: Annotations = [] (
    type $datumTypeProjection,
    value $datumProjection
  )

  // types

  outputProjection typeNameProjection: TypeName = :`string` ~~ (
    QualifiedTypeName :name,
    AnonListTypeName :elementTypeName $dataTypeNameProjection,
    AnonMapTypeName :`record`(
      keyTypeName $typeNameProjection,
      valueTypeName $dataTypeNameProjection
    )
  )

  outputProjection dataTypeNameProjection: DataTypeName = (
    typeName $typeNameProjection,
    retroTagName :`string`
  )

  outputProjection typeProjection: Type = (
    name $typeNameProjection,
    supertypes * $typeProjection,
    `abstract`,
    annotations $annotationsProjection
  ) ~ (
    VarType ( tags * $tagProjection ),
    DatumType $datumTypeProjection = (     // datumTypeProjection = typeProjection ~ DatumType
      // supertypes * $datumTypeProjection // can't merge recursive projections yet. And not needed actually: normalized version will have it as list[DatumType] with $datumTypeProjection for items anyways
      metaType $datumTypeProjection
    ) ~ (
      RecordType (
        declaredFields * $fieldProjection
        // add `computed` fields too?
      ),
      MapType (
        keyType $typeProjection
        valueType $dataTypeProjection
      ),
      ListType (
        valueType $dataTypeProjection
      ),
      PrimitiveType // empty, but gives us properly typed `name` and `supertypes` projections
    )
  )

  outputProjection tagProjection: Tag = (
    name :`string`,
    type $datumTypeProjection,
    annotations $annotationsProjection
  )

  outputProjection fieldProjection: Field = (
    name :`string`,
    valueType $dataTypeProjection,
    annotations $annotationsProjection
  )

  outputProjection dataTypeProjection : DataType = (
    type $typeProjection,
    `retro` $tagProjection
  )

  // operations

  read types { // todo remove name
    path /types
    outputProjection [] ( $typeProjection )
  }
}
