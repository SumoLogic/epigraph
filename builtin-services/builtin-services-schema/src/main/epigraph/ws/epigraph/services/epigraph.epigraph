namespace ws.epigraph.services

import epigraph.schema.Type
import epigraph.schema.TypeName
import epigraph.schema.QualifiedTypeName
import epigraph.schema.AnonListTypeName
import epigraph.schema.DataTypeName
import epigraph.schema.AnonMapTypeName
import epigraph.schema.VarType
import epigraph.schema.DatumType
import epigraph.schema.DataType
import epigraph.schema.Tag
import epigraph.schema.RecordType
import epigraph.schema.MapType
import epigraph.schema.ListType
import epigraph.schema.Field
import epigraph.schema.NameString

record EpigraphResource {
  doc = "Epigraph built-in services resource root type"

  types: map[NameString, Type]
}

resource epigraph: EpigraphResource {

  outputProjection typeNameProjection: TypeName = :`string` ~~ (
    QualifiedTypeName :segments,
    AnonListTypeName :elementTypeName $dataTypeNameProjection,
    AnonMapTypeName :`record`(
      keyTypeName $typeNameProjection,
      valueTypeName $dataTypeNameProjection
    )
  )

  outputProjection dataTypeNameProjection: DataTypeName = (
    typeName $typeNameProjection,
    retroTagName :`string`
  )

  outputProjection typeProjection: Type = (
    name $typeNameProjection,
    supertypes * $typeProjection,
    `abstract`
  ) ~ (
    VarType ( tags * $tagProjection ),
    DatumType (
      metaType $typeProjection,
    ) ~ (
      RecordType (
        declaredFields * $fieldProjection
        // add `computed` fields too?
      )
      MapType (
        keyType $typeProjection
        valueType $dataTypeProjection
      )
      ListType (
        valueType $dataTypeProjection
      )
    )
  )

  outputProjection tagProjection: Tag = (
    name :`string`,
    type $typeProjection
  )

  outputProjection fieldProjection: Field = (
    name :`string`,
    valueType $dataTypeProjection
  )

  outputProjection dataTypeProjection : DataType = (
    type $typeProjection,
    `retro` $tagProjection
  )

  read {
    outputProjection (
      types [] ( $typeProjection )
    )
  }
}
